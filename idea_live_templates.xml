<template name="bit" value="static class BIT {&#10;    long N;&#10;    long[] data;&#10;    BIT(int n) {&#10;        N = n;&#10;        data = new long[n+1];&#10;    }&#10;&#10;    long sum(int i) {&#10;        long s = 0;&#10;        while (i &gt; 0) {&#10;            s += data[i];&#10;            i -= i &amp; (-i);&#10;        }&#10;        return s;&#10;    }&#10;&#10;    long range(int i, int j) {&#10;        return sum(j) - sum(i-1);&#10;    }&#10;&#10;    void add(int i, long x) {&#10;        while (i &lt;= N) {&#10;            data[i] += x;&#10;            i += i &amp; (-i);&#10;        }&#10;    }&#10;}" description="Binary index tree" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="builddirectedgraph_stdin" value="static int[][] buildDirectedGraph(InputReader in, int n, int m) {&#10;    int[][] edges = new int[m][];&#10;    int[][] graph = new int[n][];&#10;    int[] deg = new int[n];&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = in.nextInt()-1;&#10;        int b = in.nextInt()-1;&#10;        deg[a]++;&#10;        edges[i] = new int[]{a, b};&#10;    }&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        graph[i] = new int[deg[i]];&#10;    }&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = edges[i][0];&#10;        int b = edges[i][1];&#10;        graph[a][--deg[a]] = b;&#10;    }&#10;    return graph;&#10;}&#10;&#10;" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="buildgraph_edges_array" value="static int[][] buildGraph(int n, int[][] edges) {&#10;    int m = edges.length;&#10;    int[][] graph = new int[n][];&#10;    int[] deg = new int[n];&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = edges[i][0];&#10;        int b = edges[i][1];&#10;        deg[a]++;&#10;        deg[b]++;&#10;    }&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        graph[i] = new int[deg[i]];&#10;    }&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = edges[i][0];&#10;        int b = edges[i][1];&#10;        graph[a][--deg[a]] = b;&#10;        graph[b][--deg[b]] = a;&#10;    }&#10;    return graph;&#10;}&#10;" description="int[][] style" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="buildgraph_edges_list" value="static int[][] buildGraph(int n, List&lt;int[]&gt; edges) {&#10;    int m = edges.size();&#10;    int[][] graph = new int[n][];&#10;    int[] deg = new int[n];&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = edges.get(i)[0];&#10;        int b = edges.get(i)[1];&#10;        deg[a]++;&#10;        deg[b]++;&#10;    }&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        graph[i] = new int[deg[i]];&#10;    }&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = edges.get(i)[0];&#10;        int b = edges.get(i)[1];&#10;        graph[a][--deg[a]] = b;&#10;        graph[b][--deg[b]] = a;&#10;    }&#10;    return graph;&#10;}" description="List&lt;int[]&gt; style" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="buildgraph_pair" value="static int[][] buildGraph(int[] l, int[] r) {&#10;    int n = 0;&#10;    for (int i = 0 ; i &lt; l.length ; i++) {&#10;        n = Math.max(n, l[i]);&#10;        n = Math.max(n, r[i]);&#10;    }&#10;    int m = l.length;&#10;    int[][] edges = new int[m][];&#10;    int[][] graph = new int[n][];&#10;    int[] deg = new int[n];&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        deg[l[i]]++;&#10;        deg[r[i]]++;&#10;        edges[i] = new int[]{l[i], r[i]};&#10;    }&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        graph[i] = new int[deg[i]];&#10;    }&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = edges[i][0];&#10;        int b = edges[i][1];&#10;        graph[a][--deg[a]] = b;&#10;        graph[b][--deg[b]] = a;&#10;    }&#10;    return graph;&#10;}" description="int[] a, int[] b style" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="buildgraph_stdin" value="static int[][] buildGraph(InputReader in, int n, int m) {&#10;    int[][] edges = new int[m][];&#10;    int[][] graph = new int[n][];&#10;    int[] deg = new int[n];&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = in.nextInt()-1;&#10;        int b = in.nextInt()-1;&#10;        deg[a]++;&#10;        deg[b]++;&#10;        edges[i] = new int[]{a, b};&#10;    }&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        graph[i] = new int[deg[i]];&#10;    }&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = edges[i][0];&#10;        int b = edges[i][1];&#10;        graph[a][--deg[a]] = b;&#10;        graph[b][--deg[b]] = a;&#10;    }&#10;    return graph;&#10;}" description="stdin style" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="buildweightedgraph_stdin" value="static int[][][] buildWeightedGraph(InputReader in, int n, int m) {&#10;    int[][] edges = new int[m][];&#10;    int[][][] graph = new int[n][][];&#10;    int[] deg = new int[n];&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = in.nextInt()-1;&#10;        int b = in.nextInt()-1;&#10;        int w = in.nextInt();&#10;        deg[a]++;&#10;        deg[b]++;&#10;        edges[i] = new int[]{a, b, w};&#10;    }&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        graph[i] = new int[deg[i]][2];&#10;    }&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = edges[i][0];&#10;        int b = edges[i][1];&#10;        int w = edges[i][2];&#10;        graph[a][--deg[a]][0] = b;&#10;        graph[b][--deg[b]][0] = a;&#10;        graph[a][deg[a]][1] = w;&#10;        graph[b][deg[b]][1] = w;&#10;    }&#10;    return graph;&#10;}" description="stdin style" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="combination" value="static final int MOD = 1000000007;&#10;&#10;static long pow(long a, long x) {&#10;    long res = 1;&#10;    while (x &gt; 0) {&#10;        if (x % 2 != 0) {&#10;        res = (res * a) % MOD;&#10;        }&#10;        a = (a * a) % MOD;&#10;        x /= 2;&#10;    }&#10;    return res;&#10;}&#10;&#10;static long inv(long a) {&#10;    return pow(a, MOD - 2) % MOD;&#10;}&#10;&#10;static long[] _fact;&#10;static long[] _invfact;&#10;static long comb(long ln, long lr) {&#10;    int n = (int)ln;&#10;    int r = (int)lr;&#10;    if (n &lt; 0 || r &lt; 0 || r &gt; n) {&#10;        return 0;&#10;    }&#10;    if (r &gt; n / 2) {&#10;        r = n - r;&#10;    }&#10;    return (((_fact[n] * _invfact[n - r]) % MOD) * _invfact[r]) % MOD;&#10;}&#10;&#10;static void prec(int n) {&#10;    _fact = new long[n + 1];&#10;    _invfact = new long[n + 1];&#10;    _fact[0] = 1;&#10;    _invfact[0] = 1;&#10;    for (int i = 1; i &lt;= n; i++) {&#10;        _fact[i] = _fact[i - 1] * i % MOD;&#10;        _invfact[i] = inv(_fact[i]);&#10;    }&#10;}&#10;" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="convex_hull_tech" value="static class ConvexHullTechnique {&#10;    long[][] stk;&#10;    int tail = 0;&#10;&#10;    ConvexHullTechnique(int maxLines) {&#10;        stk = new long[maxLines][2];&#10;    }&#10;&#10;    // add line : ax + b&#10;    void addLine(long a, long b) {&#10;        stk[tail][0] = a;&#10;        stk[tail][1] = b;&#10;        tail++;&#10;        while (tail &gt;= 3 &amp;&amp; compare(stk[tail-3], stk[tail-2], stk[tail-1])) {&#10;            stk[tail-2][0] = stk[tail-1][0];&#10;            stk[tail-2][1] = stk[tail-1][1];&#10;            tail--;&#10;        }&#10;    }&#10;&#10;    // a1 &lt;= a2 &lt;= a3&#10;    private boolean compare(long[] l1, long[] l2, long[] l3) {&#10;        long a1 = l1[0];&#10;        long a2 = l2[0];&#10;        long a3 = l3[0];&#10;        long b1 = l1[1];&#10;        long b2 = l2[1];&#10;        long b3 = l3[1];&#10;        return  (a2 - a1) * (b3 - b2) &gt;= (a3 - a2) * (b2 - b1);&#10;    }&#10;&#10;    long val(int lidx, long x) {&#10;        return stk[lidx][0] * x + stk[lidx][1];&#10;    }&#10;&#10;    long[] queryMax(long x) {&#10;        int min = -1;&#10;        int max = tail - 1;&#10;        while (max - min &gt; 1) {&#10;            int med = (max + min) / 2;&#10;            if (val(med, x) &lt;= val(med+1, x)) {&#10;                min = med;&#10;            } else {&#10;                max = med;&#10;            }&#10;        }&#10;        return stk[max];&#10;    }&#10;&#10;    static void verify() {&#10;        ConvexHullTechnique tech = new ConvexHullTechnique(100);&#10;        tech.addLine(-1, 3);    // y = -x + 3&#10;        tech.addLine(0, -3);    // y = -3&#10;        tech.addLine(0, -6);    // y = -6&#10;        tech.addLine(1, -12);   // y = x - 12&#10;        tech.addLine(2, -16);   // y = 2x - 16&#10;&#10;        for (int x = 0 ; x &lt;= 20 ; x++) {&#10;            debug(x, tech.queryMax(x));&#10;        }&#10;    }&#10;}&#10;" description="1次式(直線)の最大値" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="convexhull" value="static class Point implements Comparable&lt;Point&gt; {&#10;    long x;&#10;    long y;&#10;&#10;    Point(long _x, long _y) {&#10;        x = _x;&#10;        y = _y;&#10;    }&#10;&#10;    Point(Point a, Point b) {&#10;        x = b.x - a.x;&#10;        y = b.y - a.y;&#10;    }&#10;&#10;    public int compareTo(Point o) {&#10;        if (x != o.x) {&#10;            return Long.signum(x - o.x);&#10;        }&#10;        return Long.signum(y - o.y);&#10;    }&#10;&#10;    public long det(Point other) {&#10;        return x * other.y - y * other.x;&#10;    }&#10;&#10;    public String toString() {&#10;        return &quot;(&quot; + x + &quot;,&quot; + y + &quot;)&quot;;&#10;    }&#10;}&#10;&#10;public static List&lt;Point&gt; convexHull(Point[] points) {&#10;    int n = points.length;&#10;    Arrays.sort(points);&#10;    Point[] candidate = new Point[n*2];&#10;    int k = 0;&#10;&#10;    // downer&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        while (k &gt; 1) {&#10;            Point a = new Point(candidate[k-2], candidate[k-1]);&#10;            Point b = new Point(candidate[k-1], points[i]);&#10;            if (a.det(b) &lt;= 0) {&#10;                k--;&#10;            } else {&#10;                break;&#10;            }&#10;        }&#10;        candidate[k++] = points[i];&#10;    }&#10;&#10;    // upper&#10;    int t = k;&#10;    for (int i = n-2 ; i &gt;= 0 ; i--) {&#10;        while (k &gt; t) {&#10;            Point a = new Point(candidate[k-2], candidate[k-1]);&#10;            Point b = new Point(candidate[k-1], points[i]);&#10;            if (a.det(b) &lt;= 0) {&#10;                k--;&#10;            } else {&#10;                break;&#10;            }&#10;        }&#10;        candidate[k++] = points[i];&#10;    }&#10;    List&lt;Point&gt; ret = new ArrayList&lt;Point&gt;();&#10;    for (int i = 0 ; i &lt; k - 1 ; i++) {&#10;        ret.add(candidate[i]);&#10;    }&#10;    return ret;&#10;}" description="凸包" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="count_distinct_value_in_array" value="static class Event implements Comparable&lt;Event&gt; {&#10;    int fr;&#10;    int to;&#10;    int val;  // plus: array value, 0 or minus: -(query index)&#10;&#10;    Event(int f, int t, int ty) {&#10;        fr = f;&#10;        to = t;&#10;        val = ty;&#10;    }&#10;&#10;    @Override&#10;    public int compareTo(Event o) {&#10;        if (fr != o.fr) {&#10;            return o.fr - fr;&#10;        }&#10;        return o.val - val;&#10;    }&#10;}&#10;&#10;static int[] countDistinctValues(int[] arr, int[][] query) {&#10;    int q = query.length;&#10;    int n = arr.length;&#10;&#10;    BIT bit = new BIT(n+5);&#10;&#10;    Event[] events = new Event[q+n];&#10;    for (int i = 0; i &lt; q ; i++) {&#10;        events[i] = new Event(query[i][0], query[i][1], -i);&#10;    }&#10;    for (int i = 0; i &lt; n ; i++) {&#10;        events[q+i] = new Event(i, i, arr[i]+1);&#10;    }&#10;    Arrays.sort(events);&#10;&#10;    int[] ret = new int[q];&#10;    int max = 0;&#10;    for (int i = 0; i &lt; arr.length ; i++) {&#10;        max = Math.max(max, arr[i]);&#10;    }&#10;    int[] lastFound = new int[max+10];&#10;    for (Event e : events) {&#10;        if (e.val &lt;= 0) {&#10;            int qidx = -e.val;&#10;            ret[qidx] = (int)bit.range(e.fr+1, e.to+1);&#10;        } else {&#10;            if (lastFound[e.val] != 0) {&#10;                bit.add(lastFound[e.val], -1);&#10;            }&#10;            bit.add(e.fr+1, 1);&#10;            lastFound[e.val] = e.fr+1;&#10;        }&#10;    }&#10;    return ret;&#10;}" description="配列中、指定範囲に数が何種類存在するか調べる" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="d4" value="private int[] dx = new int[]{0, -1, 0, 1};&#10;private int[] dy = new int[]{-1, 0, 1, 0};&#10;" description="direction four" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="dbg" value="public static void debug(Object... o) {&#10;    System.err.println(Arrays.deepToString(o));&#10;}&#10;" description="debug" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="dijkstra" value="static class Dijkstra {&#10;    int n;&#10;    int[][][] graph;&#10;&#10;    class State implements Comparable&lt;State&gt; {&#10;        int now;&#10;        long time;&#10;&#10;        State(int n, long t) {&#10;            now = n;&#10;            time = t;&#10;        }&#10;&#10;        @Override&#10;        public int compareTo(State o) {&#10;            return Long.compare(time, o.time);&#10;        }&#10;    }&#10;&#10;    public Dijkstra(int[][][] graph) {&#10;        this.n = graph.length;&#10;        this.graph = graph;&#10;    }&#10;&#10;    long[] doit(int from) {&#10;        long[] dp = new long[n];&#10;        Arrays.fill(dp, Long.MAX_VALUE / 10);&#10;        Queue&lt;State&gt; q = new PriorityQueue&lt;&gt;();&#10;        q.add(new State(from, 0));&#10;        dp[0] = 0;&#10;        while (q.size() &gt;= 1) {&#10;            State st = q.poll();&#10;            for (int[] e : graph[st.now]) {&#10;                long time = st.time + e[1];&#10;                if (dp[e[0]] &gt; time) {&#10;                    dp[e[0]] = time;&#10;                    q.add(new State(e[0], time));&#10;                }&#10;            }&#10;        }&#10;        return dp;&#10;    }&#10;}" description="Dijkstra" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="eulertour" value="static class EulerTour {&#10;    int n;&#10;    int[][] graph;&#10;    int[] parent;&#10;    int[] ar;&#10;    int[] cn;&#10;    int ai = 0;&#10;&#10;    public EulerTour(int[][] graph) {&#10;        this.graph = graph;&#10;        this.n = graph.length;&#10;        this.parent = new int[n];&#10;        this.ar = new int[2*n];&#10;        this.cn = new int[n];&#10;    }&#10;&#10;    private void go(int now) {&#10;        ar[ai++] = now;&#10;        int head = now;&#10;        while (head != -1) {&#10;            if (cn[head] != 0) {&#10;                break;&#10;            }&#10;            ar[ai++] = -(head+1);&#10;            head = parent[head];&#10;            if (head != -1) {&#10;                cn[head]--;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void parentChild(int root) {&#10;        int[] que = new int[4*n];&#10;        int qh = 0;&#10;        int qt = 0;&#10;        que[qh++] = root;&#10;        que[qh++] = -1;&#10;        while (qt &lt; qh) {&#10;            int now = que[qt++];&#10;            int par = que[qt++];&#10;            parent[now] = par;&#10;            for (int to : graph[now]) {&#10;                if (to != par) {&#10;                    que[qh++] = to;&#10;                    que[qh++] = now;&#10;                }&#10;            }&#10;        }&#10;        for (int i = 0; i &lt; n ; i++) {&#10;            cn[i] = (parent[i] == -1) ? graph[i].length : graph[i].length-1;&#10;        }&#10;    }&#10;&#10;    void build(int root) {&#10;        parentChild(root);&#10;&#10;        Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();&#10;        ai = 0;&#10;        stk.push(root);&#10;        stk.push(-1);&#10;        while (stk.size() &gt;= 1) {&#10;            int par = stk.pop();&#10;            int now = stk.pop();&#10;            go(now);&#10;            for (int to : graph[now]) {&#10;                if (to != par) {&#10;                    stk.push(to);&#10;                    stk.push(now);&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" description="非再帰版EulerTour" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="gcd" value="public static long gcd(long a, long b) {&#10;    return b == 0 ? a : gcd(b, a%b);&#10;}&#10;" description="gcd" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="geometry_2dpoint" value="static class Point implements Comparable&lt;Point&gt; {&#10;    long x;&#10;    long y;&#10;&#10;    public Point(long _x, long _y) {&#10;        x = _x;&#10;        y = _y;&#10;    }&#10;&#10;    long dot(Point o) {&#10;        return x * o.x + y * o.y;&#10;    }&#10;&#10;    long cross(Point o) {&#10;        return x * o.y - y * o.x;&#10;    }&#10;&#10;    Point to(Point o) {&#10;        return new Point(o.x - x, o.y - y);&#10;    }&#10;&#10;    static boolean innerTriangle(Point x1, Point x2, Point x3, Point y) {&#10;        Point v1 = x1.to(x2);&#10;        Point v2 = x2.to(x3);&#10;        Point v3 = x3.to(x1);&#10;        Point u1 = x1.to(y);&#10;        Point u2 = x2.to(y);&#10;        Point u3 = x3.to(y);&#10;        boolean c1 = v1.cross(u1) &gt; 0;&#10;        boolean c2 = v2.cross(u2) &gt; 0;&#10;        boolean c3 = v3.cross(u3) &gt; 0;&#10;        return c1 == c2 &amp;&amp; c2 == c3;&#10;    }&#10;&#10;    @Override&#10;    public int compareTo(Point o) {&#10;        return x == o.x ? Long.compare(y, o.y) : Long.compare(x, o.x);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return String.format(&quot;(%d,%d)&quot;, x, y);&#10;    }&#10;}" description="二次元幾何" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="ir" value="static class InputReader {&#10;    private InputStream stream;&#10;    private byte[] buf = new byte[1024];&#10;    private int curChar;&#10;    private int numChars;&#10;    private SpaceCharFilter filter;&#10;&#10;    public InputReader(InputStream stream) {&#10;          this.stream = stream;&#10;    }&#10;&#10;    public int next() {&#10;          if (numChars == -1)&#10;                throw new InputMismatchException();&#10;          if (curChar &gt;= numChars) {&#10;                curChar = 0;&#10;                try {&#10;                      numChars = stream.read(buf);&#10;                } catch (IOException e) {&#10;                      throw new InputMismatchException();&#10;                }&#10;                if (numChars &lt;= 0)&#10;                      return -1;&#10;          }&#10;          return buf[curChar++];&#10;    }&#10;&#10;    public int nextInt() {&#10;          int c = next();&#10;          while (isSpaceChar(c))&#10;                c = next();&#10;          int sgn = 1;&#10;          if (c == '-') {&#10;                sgn = -1;&#10;                c = next();&#10;          }&#10;          int res = 0;&#10;          do {&#10;                if (c &lt; '0' || c &gt; '9')&#10;                      throw new InputMismatchException();&#10;                res *= 10;&#10;                res += c - '0';&#10;                c = next();&#10;          } while (!isSpaceChar(c));&#10;          return res * sgn;&#10;    }&#10;&#10;    public boolean isSpaceChar(int c) {&#10;          if (filter != null)&#10;                return filter.isSpaceChar(c);&#10;          return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;&#10;    }&#10;&#10;    public interface SpaceCharFilter {&#10;          public boolean isSpaceChar(int ch);&#10;    }&#10;}" description="input reader" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="lowlink" value="static class LowLink {&#10;    int n;&#10;    int[] parent;&#10;    int[] cnt;&#10;    int[] ord;&#10;    int[] low;&#10;    int[][] graph;&#10;    int[][] dfsTree;&#10;    boolean[] root;&#10;    int oi = 0;&#10;&#10;    public LowLink(int[][] graph) {&#10;        this.n = graph.length;&#10;        this.parent = new int[n];&#10;        this.graph = graph;&#10;        this.ord = new int[n];&#10;        this.low = new int[n];&#10;        this.root = new boolean[n];&#10;        this.cnt = new int[n];&#10;        this.dfsTree = new int[n][];&#10;        for (int i = 0; i &lt; n ; i++) {&#10;            this.dfsTree[i] = new int[graph[i].length];&#10;            Arrays.fill(this.dfsTree[i], -1);&#10;        }&#10;        Arrays.fill(parent, -1);&#10;        Arrays.fill(ord, -1);&#10;        Arrays.fill(low, n);&#10;    }&#10;&#10;    public void build() {&#10;        for (int i = 0 ; i &lt; n ; i++) {&#10;            if (ord[i] == -1) {&#10;                root[i] = true;&#10;                // optional&#10;                // dfsWithoutRecursive(i);&#10;                dfs(i, -1);&#10;                dfs0(i, -1);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void dfsWithoutRecursive(int rt) {&#10;        Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();&#10;        stk.push(rt);&#10;        stk.push(-1);&#10;        stk.push(-1);&#10;&#10;        List&lt;Integer&gt; vi = new ArrayList&lt;&gt;();&#10;        while (stk.size() &gt;= 1) {&#10;            int pid = stk.pop();&#10;            int par = stk.pop();&#10;            int now = stk.pop();&#10;            if (ord[now] != -1) {&#10;                continue;&#10;            }&#10;            vi.add(now);&#10;            if (pid &gt;= 0) {&#10;                dfsTree[par][pid] = now;&#10;            }&#10;            parent[now] = par;&#10;            ord[now] = oi;&#10;            low[now] = oi++;&#10;            for (int i = 0 ; i &lt; graph[now].length ; i++) {&#10;                int to = graph[now][i];&#10;                if (to == par) {&#10;                    continue;&#10;                }&#10;                if (ord[to] == -1) {&#10;                    stk.push(to);&#10;                    stk.push(now);&#10;                    stk.push(i);&#10;                }&#10;            }&#10;        }&#10;&#10;        for (int i = vi.size()-1 ; i &gt;= 0 ; i--) {&#10;            int now = vi.get(i);&#10;            cnt[now] = 1;&#10;            for (int j = 0 ; j &lt; graph[now].length ; j++) {&#10;                int to = graph[now][j];&#10;                if (to == parent[now]) {&#10;                    // ignore parent edge&#10;                    continue;&#10;                }&#10;                if (dfsTree[now][j] != -1) {&#10;                    cnt[now] += cnt[dfsTree[now][j]];&#10;                    low[now] = Math.min(low[now], low[dfsTree[now][j]]);&#10;                } else {&#10;                    // that's a back edge!&#10;                    low[now] = Math.min(low[now], ord[to]);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void dfs(int now, int par) {&#10;        if (ord[now] != -1) {&#10;            return;&#10;        }&#10;        ord[now] = oi;&#10;        low[now] = oi++;&#10;        for (int i = 0 ; i &lt; graph[now].length ; i++) {&#10;            int to = graph[now][i];&#10;            if (to == par) {&#10;                continue;&#10;            }&#10;            if (ord[to] == -1) {&#10;                dfsTree[now][i] = to;&#10;                dfs(to, now);&#10;                low[now] = Math.min(low[now], low[to]);&#10;            } else {&#10;                // that's a back edge!&#10;                low[now] = Math.min(low[now], ord[to]);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void dfs0(int now, int par) {&#10;        cnt[now] = 1;&#10;        for (int to : dfsTree[now]) {&#10;            if (to == -1 || to == par) {&#10;                continue;&#10;            }&#10;            dfs0(to, now);&#10;            cnt[now] += cnt[to];&#10;        }&#10;    }&#10;&#10;    private boolean isBridge(int u, int v) {&#10;        return ord[u] &lt; low[v];&#10;    }&#10;&#10;    private boolean isArticulationPoint(int u) {&#10;        if (root[u]) {&#10;            int cn = 0;&#10;            for (int to : dfsTree[u]) {&#10;                if (to != -1) {&#10;                    cn++;&#10;                }&#10;            }&#10;            return cn &gt;= 2;&#10;        } else {&#10;            for (int to : dfsTree[u]) {&#10;                if (to != -1 &amp;&amp; ord[u] &lt;= low[to]) {&#10;                    return true;&#10;                }&#10;            }&#10;            return false;&#10;        }&#10;    }&#10;}" description="橋とか関節点とかを求めるやつ" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="matching" value="public static class Matching {&#10;    // Edmonds' cardinality matching algorithm. O(n^3)&#10;    int[][] graph;&#10;&#10;    int n;&#10;    int[] mu;&#10;    int[] phi;&#10;    int[] rho;&#10;    boolean[] scanned;&#10;&#10;    public Matching(int[][] graph) {&#10;        this.n = graph.length;&#10;        this.graph = graph;&#10;        mu = new int[n];&#10;        phi = new int[n];&#10;        rho = new int[n];&#10;        scanned = new boolean[n];&#10;        for (int i = 0; i &lt; n ; i++) {&#10;            mu[i] = phi[i] = rho[i] = i;&#10;        }&#10;    }&#10;&#10;    public int[] solve() {&#10;        int x = -1;&#10;        while (true) {&#10;            if (x == -1) {&#10;                for (int i = 0; i &lt; n; i++) {&#10;                    if (scanned[i]) {&#10;                        continue;&#10;                    }&#10;                    if (isEven(i)) {&#10;                        x = i;&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;            if (x == -1) {&#10;                break;&#10;            }&#10;            int y = -1;&#10;            for (int to : graph[x]) {&#10;                if (isOuter(to) || (isEven(to) &amp;&amp; rho[to] != rho[x])) {&#10;                    y = to;&#10;                }&#10;            }&#10;            if (y == -1) {&#10;                scanned[x] = true;&#10;                x = -1;&#10;            } else if (isOuter(y)) {&#10;                phi[y] = x;&#10;            } else {&#10;                int[] dx = new int[n];&#10;                int[] dy = new int[n];&#10;                Arrays.fill(dx, -1);&#10;                Arrays.fill(dy, -1);&#10;                for (int k = 0, w = x ; dx[w] &lt; 0 ; w = (k % 2 == 1 ? mu[w] : phi[w])) {&#10;                    dx[w] = k++;&#10;                }&#10;                for (int k = 0, w = y ; dy[w] &lt; 0 ; w = (k % 2 == 1 ? mu[w] : phi[w])) {&#10;                    dy[w] = k++;&#10;                }&#10;                boolean disjoint = true;&#10;                for (int i = 0; i &lt; n ; i++) {&#10;                    if (dx[i] &gt;= 0 &amp;&amp; dy[i] &gt; 0) {&#10;                        disjoint = false;&#10;                        break;&#10;                    }&#10;                }&#10;                if (disjoint) {&#10;                    for (int v = 0; v &lt; n ; v++) {&#10;                        if (dx[v] % 2 == 1) {&#10;                            mu[phi[v]] = v;&#10;                            mu[v] = phi[v];&#10;                        }&#10;                    }&#10;                    for (int v = 0; v &lt; n ; v++) {&#10;                        if (dy[v] % 2 == 1) {&#10;                            mu[phi[v]] = v;&#10;                            mu[v] = phi[v];&#10;                        }&#10;                    }&#10;                    mu[x] = y;&#10;                    mu[y] = x;&#10;                    for (int v = 0; v &lt; n ; v++) {&#10;                        phi[v] = rho[v] = v;&#10;                        scanned[v] = false;&#10;                    }&#10;                    x = -1;&#10;                } else {&#10;                    int r = x;&#10;                    int d = n;&#10;                    for (int v = 0; v &lt; n ; v++) {&#10;                        if (dx[v] &gt;= 0 &amp;&amp; dy[v] &gt;= 0 &amp;&amp; rho[v] == v &amp;&amp; d &gt; dx[v]) {&#10;                            d = dx[v];&#10;                            r = v;&#10;                        }&#10;                    }&#10;                    for (int v = 0; v &lt; n ; v++) {&#10;                        if (dx[v] &lt;= d &amp;&amp; dx[v] % 2 == 1 &amp;&amp; rho[phi[v]] != r) {&#10;                            phi[phi[v]] = v;&#10;                        }&#10;                    }&#10;                    for (int v = 0; v &lt; n ; v++) {&#10;                        if (dy[v] &lt;= d &amp;&amp; dy[v] % 2 == 1 &amp;&amp; rho[phi[v]] != r) {&#10;                            phi[phi[v]] = v;&#10;                        }&#10;                    }&#10;                    if (rho[x] != r) {&#10;                        phi[x] = y;&#10;                    }&#10;                    if (rho[y] != r) {&#10;                        phi[y] = x;&#10;                    }&#10;                    for (int v = 0; v &lt; n ; v++) {&#10;                        if (dx[rho[v]] &gt;= 0 || dy[rho[v]] &gt;= 0) {&#10;                            rho[v] = r;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return mu;&#10;    }&#10;&#10;    private boolean isEven(int idx) {&#10;        return mu[idx] == idx || (mu[idx] != idx &amp;&amp; phi[mu[idx]] != mu[idx]);&#10;    }&#10;&#10;    private boolean isOdd(int idx) {&#10;        return mu[idx] != idx &amp;&amp; phi[mu[idx]] == mu[idx] &amp;&amp; phi[idx] != idx;&#10;    }&#10;&#10;    private boolean isOuter(int idx) {&#10;        return mu[idx] != idx &amp;&amp; phi[mu[idx]] == mu[idx] &amp;&amp; phi[idx] == idx;&#10;    }&#10;}" description="一般マッチング" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="maxflow_dinic" value="public static class MaxFlowDinic {&#10;    public List&lt;int[]&gt;[] graph;&#10;    public int[] deg;&#10;&#10;    public int[] level;&#10;    public int[] itr;&#10;&#10;    public int[] que;&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public void init(int size) {&#10;        graph = new List[size];&#10;        for (int i = 0; i &lt; size ; i++) {&#10;            graph[i] = new ArrayList&lt;int[]&gt;();&#10;        }&#10;        deg = new int[size];&#10;        level = new int[size];&#10;        itr = new int[size];&#10;        que = new int[size+10];&#10;    }&#10;    public void edge(int from, int to, int cap) {&#10;        int fdeg = deg[from];&#10;        int tdeg = deg[to];&#10;        graph[from].add(new int[]{to, cap, tdeg});&#10;        graph[to].add(new int[]{from, 0, fdeg});&#10;        deg[from]++;&#10;        deg[to]++;&#10;    }&#10;&#10;    public int dfs(int v, int t, int f) {&#10;        if (v == t) return f;&#10;        for (int i = itr[v] ; i &lt; graph[v].size() ; i++) {&#10;            itr[v] = i;&#10;            int[] e = graph[v].get(i);&#10;            if (e[1] &gt; 0 &amp;&amp; level[v] &lt; level[e[0]]) {&#10;                int d = dfs(e[0], t, Math.min(f, e[1]));&#10;                if (d &gt; 0) {&#10;                    e[1] -= d;&#10;                    graph[e[0]].get(e[2])[1] += d;&#10;                    return d;&#10;                }&#10;            }&#10;        }&#10;        return 0;&#10;    }&#10;&#10;    public void bfs(int s) {&#10;        Arrays.fill(level, -1);&#10;        int qh = 0;&#10;        int qt = 0;&#10;        level[s] = 0;&#10;        que[qh++] = s;&#10;        while (qt &lt; qh) {&#10;            int v = que[qt++];&#10;            for (int i = 0; i &lt; graph[v].size() ; i++) {&#10;                int[] e = graph[v].get(i);&#10;                if (e[1] &gt; 0 &amp;&amp; level[e[0]] &lt; 0) {&#10;                    level[e[0]] = level[v] + 1;&#10;                    que[qh++] = e[0];&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public int max_flow(int s, int t) {&#10;        int flow = 0;&#10;        while (true) {&#10;            bfs(s);&#10;            if (level[t] &lt; 0) {&#10;                return flow;&#10;            }&#10;            Arrays.fill(itr, 0);&#10;            while (true) {&#10;                int f = dfs(s, t, Integer.MAX_VALUE);&#10;                if (f &lt;= 0) {&#10;                    break;&#10;                }&#10;                flow += f;&#10;            }&#10;        }&#10;    }&#10;}" description="Dinicのアルゴリズムによる最大流" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="maxflow_ford" value="public static class MaxFlowFord {&#10;    public class Edge {&#10;        int to;&#10;        int cap;&#10;        int rev;&#10;        public Edge(int _to, int _cap, int _rev) {&#10;            to = _to;&#10;            cap = _cap;&#10;            rev = _rev;&#10;        }&#10;    }&#10;&#10;    public List&lt;Edge&gt;[] graph;&#10;    public boolean[] used;&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public void init(int size) {&#10;        graph = new List[size];&#10;        for (int i = 0; i &lt; size ; i++) {&#10;            graph[i] = new ArrayList&lt;Edge&gt;();&#10;        }&#10;        used = new boolean[size];&#10;    }&#10;    public void edge(int from, int to, int cap) {&#10;        graph[from].add(new Edge(to, cap, graph[to].size()));&#10;        graph[to].add(new Edge(from, 0, graph[from].size() - 1));&#10;    }&#10;&#10;    public int dfs(int v, int t, int f) {&#10;        if (v == t) return f;&#10;        used[v] = true;&#10;        for (Edge e : graph[v]) {&#10;            if (!used[e.to] &amp;&amp; e.cap &gt; 0) {&#10;                int d = dfs(e.to, t, Math.min(f, e.cap));&#10;                if (d &gt; 0) {&#10;                    e.cap -= d;&#10;                    graph[e.to].get(e.rev).cap += d;&#10;                    return d;&#10;                }&#10;            }&#10;        }&#10;        return 0;&#10;    }&#10;    public int max_flow(int s, int t) {&#10;        int flow = 0;&#10;        while (true) {&#10;            used = new boolean[graph.length];&#10;            int f = dfs(s, t, Integer.MAX_VALUE);&#10;            if (f == 0) {&#10;                break;&#10;            }&#10;            flow += f;&#10;        }&#10;        return flow;&#10;    }&#10;}" description="Ford-Fulkersonアルゴリズムによる最大流" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="mincostflow" value="public static class MinCostFlow {&#10;    public static class State implements Comparable&lt;State&gt; {&#10;        int dist;&#10;        int now;&#10;        public State(int _n, int _d) {&#10;            now = _n;&#10;            dist = _d;&#10;        }&#10;&#10;        @Override&#10;        public int compareTo(State o) {&#10;            return dist - o.dist;&#10;        }&#10;    }&#10;&#10;    public static class Edge {&#10;        int to;&#10;        int cap;&#10;        int rev;&#10;        int cost;&#10;        public Edge(int _to, int _cap, int _cost, int _rev) {&#10;            to = _to;&#10;            cap = _cap;&#10;            rev = _rev;&#10;            cost = _cost;&#10;        }&#10;    }&#10;&#10;    public static int INF = 1000000000;&#10;    public static int V;&#10;    public static int[] h;&#10;    public static int[] dist;&#10;    public static int[] prevv, preve;&#10;    public static List&lt;Edge&gt;[] graph;&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public static void init(int size) {&#10;        graph = new List[size];&#10;        for (int i = 0 ; i &lt; size ; i++) {&#10;            graph[i] = new ArrayList&lt;Edge&gt;();&#10;        }&#10;        dist = new int[size];&#10;        prevv = new int[size];&#10;        preve = new int[size];&#10;        h = new int[size];&#10;        V = size;&#10;    }&#10;&#10;    public static void edge(int from, int to, int cap, int cost) {&#10;        graph[from].add(new Edge(to, cap, cost, graph[to].size()));&#10;        graph[to].add(new Edge(from, 0, -cost, graph[from].size() - 1));&#10;    }&#10;&#10;    public static long min_cost_flow_be(int s, int t, int f) {&#10;        long res = 0;&#10;        Arrays.fill(h, 0);&#10;&#10;        // make sure that topo-sorted&#10;        for (int i = 0; i &lt; V ; i++) {&#10;            for (Edge e : graph[i]) {&#10;                if (e.cap &gt;= 1) {&#10;                    h[e.to] = Math.min(h[e.to], h[i] + e.cost);&#10;                }&#10;            }&#10;        }&#10;&#10;        Queue&lt;State&gt; q = new PriorityQueue&lt;State&gt;();&#10;        while (f &gt; 0) {&#10;            q.clear();&#10;            Arrays.fill(dist, INF);&#10;            dist[s] = 0;&#10;            q.add(new State(s, 0));&#10;            while (q.size() &gt;= 1) {&#10;                State stat = q.poll();&#10;                int v = stat.now;&#10;                if (dist[v] &lt; stat.dist) {&#10;                    continue;&#10;                }&#10;                for (int i = 0 ; i &lt; graph[v].size(); i++) {&#10;                    Edge e = graph[v].get(i);&#10;                    if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[v] + e.cost + h[v] - h[e.to]) {&#10;                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];&#10;                        prevv[e.to] = v;&#10;                        preve[e.to] = i;&#10;                        q.add(new State(e.to, dist[e.to]));&#10;                    }&#10;                }&#10;            }&#10;            if (dist[t] == INF) {&#10;                return res;&#10;            }&#10;            for (int v = 0 ; v &lt; V ; v++) {&#10;                h[v] += dist[v];&#10;            }&#10;            long d = f;&#10;            for (int v = t ; v != s ; v = prevv[v]) {&#10;                d = Math.min(d, graph[prevv[v]].get(preve[v]).cap);&#10;            }&#10;            f -= d;&#10;            res += d * h[t];&#10;            for (int v = t ; v != s ; v = prevv[v]) {&#10;                Edge e = graph[prevv[v]].get(preve[v]);&#10;                e.cap -= d;&#10;                Edge rev = graph[v].get(e.rev);&#10;                rev.cap += d;&#10;            }&#10;        }&#10;        return res;&#10;    }&#10;&#10;    public static long min_cost_flow(int s, int t, int f) {&#10;        long res = 0;&#10;        Arrays.fill(h, 0);&#10;        Queue&lt;State&gt; q = new PriorityQueue&lt;State&gt;();&#10;        while (f &gt; 0) {&#10;            q.clear();&#10;            Arrays.fill(dist, INF);&#10;            dist[s] = 0;&#10;            q.add(new State(s, 0));&#10;            while (q.size() &gt;= 1) {&#10;                State stat = q.poll();&#10;                int v = stat.now;&#10;                if (dist[v] &lt; stat.dist) {&#10;                    continue;&#10;                }&#10;                for (int i = 0 ; i &lt; graph[v].size(); i++) {&#10;                    Edge e = graph[v].get(i);&#10;                    if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[v] + e.cost + h[v] - h[e.to]) {&#10;                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];&#10;                        prevv[e.to] = v;&#10;                        preve[e.to] = i;&#10;                        q.add(new State(e.to, dist[e.to]));&#10;                    }&#10;                }&#10;            }&#10;            if (dist[t] == INF) {&#10;                return res;&#10;            }&#10;            for (int v = 0 ; v &lt; V ; v++) {&#10;                h[v] += dist[v];&#10;            }&#10;            long d = f;&#10;            for (int v = t ; v != s ; v = prevv[v]) {&#10;                d = Math.min(d, graph[prevv[v]].get(preve[v]).cap);&#10;            }&#10;            f -= d;&#10;            res += d * h[t];&#10;            for (int v = t ; v != s ; v = prevv[v]) {&#10;                Edge e = graph[prevv[v]].get(preve[v]);&#10;                e.cap -= d;&#10;                Edge rev = graph[v].get(e.rev);&#10;                rev.cap += d;&#10;            }&#10;        }&#10;        return res;&#10;    }&#10;}&#10;" description="最小費用流" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="primes" value="static int[] generatePrimes(int upto) {&#10;    boolean[] isp = new boolean[upto];&#10;    Arrays.fill(isp, true);&#10;    isp[0] = isp[1] = false;&#10;&#10;    int pi = 0;&#10;    for (int i = 2; i &lt; upto ; i++) {&#10;        if (isp[i]) {&#10;            pi++;&#10;            for (int j = i * 2; j &lt; upto; j += i) {&#10;                isp[j] = false;&#10;            }&#10;        }&#10;    }&#10;&#10;    int[] ret = new int[pi];&#10;    int ri = 0;&#10;    for (int i = 2 ; i &lt; upto ; i++) {&#10;        if (isp[i]) {&#10;            ret[ri++] = i;&#10;        }&#10;    }&#10;    return ret;&#10;}" description="素数生成" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="rbst_lazy_persistent" value="static class Node {&#10;    static  Random _rnd = new Random(1);&#10;&#10;    Node left, right;&#10;    long value;&#10;    long lazyValue;&#10;    long sum;&#10;    int count;&#10;&#10;    public Node(long v) {&#10;        value = v;&#10;        lazyValue = 0;&#10;        Node.update(this);&#10;    }&#10;&#10;    public Node clone() {&#10;        Node n = new Node(value);&#10;        n.left = left;&#10;        n.right = right;&#10;        n.lazyValue = lazyValue;&#10;        return update(n);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        StringBuilder builder = new StringBuilder();&#10;        builder.append(&quot;Node [value=&quot;);&#10;        builder.append(value);&#10;        builder.append(&quot;, count=&quot;);&#10;        builder.append(count);&#10;        builder.append(&quot;, plus=&quot;);&#10;        builder.append(lazyValue);&#10;        builder.append(&quot;, sum=&quot;);&#10;        builder.append(sum);&#10;        builder.append(&quot;]&quot;);&#10;        return builder.toString();&#10;    }&#10;&#10;&#10;    static Node update(Node c) {&#10;        if (c == null) {&#10;            return null;&#10;        }&#10;        c.count = 1 + count(c.left) + count(c.right);&#10;        c.sum = c.value + count(c) * c.lazyValue + sum(c.left) + sum(c.right);&#10;        return c;&#10;    }&#10;&#10;    static Node propergate(Node c) {&#10;        if (c == null) {&#10;            return null;&#10;        }&#10;        if (c.lazyValue == 0) {&#10;            return c.clone();&#10;        }&#10;        Node nc = c.clone();&#10;        if (nc.left != null) {&#10;            nc.left = c.left.clone();&#10;            nc.left.lazyValue += c.lazyValue;&#10;            update(nc.left);&#10;        }&#10;        if (nc.right != null) {&#10;            nc.right = c.right.clone();&#10;            nc.right.lazyValue += c.lazyValue;&#10;            update(nc.right);&#10;        }&#10;        nc.value += nc.lazyValue;&#10;        nc.lazyValue = 0;&#10;        return update(nc);&#10;    }&#10;&#10;    static int count(Node c) {&#10;        return c == null ? 0 : c.count;&#10;    }&#10;&#10;    static long sum(Node c) {&#10;        return c == null ? 0 : c.sum;&#10;    }&#10;&#10;&#10;    static Node merge(Node a, Node b) {&#10;        if (a == null) {&#10;            return b;&#10;        }&#10;        if (b == null) {&#10;            return a;&#10;        }&#10;        Node ac = propergate(a);&#10;        Node bc = propergate(b);&#10;        if (_rnd.nextInt(a.count + b.count) &lt; a.count) {&#10;            ac.right = merge(a.right, bc);&#10;            return update(ac);&#10;        } else {&#10;            bc.left = merge(ac, bc.left);&#10;            return update(bc);&#10;        }&#10;    }&#10;&#10;    static Node[] split(Node c, int k) {&#10;        if (c == null) {&#10;            return new Node[2];&#10;        }&#10;        if (k &lt;= count(c.left)) {&#10;            Node cc = propergate(c);&#10;            Node[] s = split(cc.left, k);&#10;            cc.left = s[1];&#10;            s[1] = update(cc);&#10;            return s;&#10;        } else {&#10;            Node cc = propergate(c);&#10;            Node[] s = split(cc.right, k - count(cc.left) - 1);&#10;            cc.right = s[0];&#10;            s[0] = update(cc);&#10;            return s;&#10;        }&#10;    }&#10;&#10;    public static Node add(Node a, int l, int r, int v) {&#10;        if(a == null || r &lt;= 0 || count(a) &lt;= l) {&#10;            return a;&#10;        }&#10;        if(l &lt;= 0 &amp;&amp; count(a) &lt;= r) {&#10;            propergate(a);&#10;            Node ac = a.clone();&#10;            ac.lazyValue += v;&#10;            return update(ac);&#10;        }else{&#10;            propergate(a);&#10;            Node ac = a.clone();&#10;            if(0 &lt; r &amp;&amp; l &lt; count(a.left)) {&#10;                ac.left = add(a.left, l, r, v);&#10;            }&#10;            if(count(a.left)+1 &lt; r &amp;&amp; l &lt; count(a)) {&#10;                ac.right = add(a.right, l-count(a.left)-1, r-count(a.left)-1, v);&#10;            }&#10;            if(l &lt;= count(a.left) &amp;&amp; count(a.left) &lt; r){&#10;                ac.value += v;&#10;            }&#10;            return update(ac);&#10;        }&#10;    }&#10;&#10;    public static long sum(Node a, int l, int r) {&#10;        if(a == null || r &lt;= 0 || count(a) &lt;= l) {&#10;            return 0;&#10;        }&#10;        if(l &lt;= 0 &amp;&amp; count(a) &lt;= r) {&#10;            return a.sum;&#10;        } else {&#10;            long ret = 0;&#10;            if(0 &lt; r &amp;&amp; l &lt; count(a.left)) {&#10;                ret += sum(a.left, l, r);&#10;            }&#10;            if(count(a.left)+1 &lt; r &amp;&amp; l &lt; count(a)) {&#10;                ret += sum(a.right, l-count(a.left)-1, r-count(a.left)-1);&#10;            }&#10;            if(l &lt;= count(a.left) &amp;&amp; count(a.left) &lt; r){&#10;                ret += a.value;&#10;            }&#10;            ret += a.lazyValue * (Math.min(r, count(a)) - Math.max(0, l));&#10;            return ret;&#10;        }&#10;    }&#10;}&#10;" description="永続遅延評価平衡二分探索木" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="reverse_directedgraph" value="static int[][] reverseDirectedGraph(int[][] graph) {&#10;    int n = graph.length;&#10;    int[] deg = new int[n];&#10;&#10;    List&lt;int[]&gt; edges = new ArrayList&lt;&gt;();&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        for (int j : graph[i]) {&#10;            edges.add(new int[]{j, i});&#10;            deg[j]++;&#10;        }&#10;    }&#10;&#10;    int[][] ret = new int[n][];&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        ret[i] = new int[deg[i]];&#10;    }&#10;    for (int[] edge : edges) {&#10;        int a = edge[0];&#10;        int b = edge[1];&#10;        ret[a][--deg[a]] = b;&#10;    }&#10;    return ret;&#10;}&#10;&#10;" description="辺の向きを逆にしたグラフを作る" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="suffix_array" value="static class SuffixArray {&#10;    int n;&#10;    char[] base;&#10;&#10;    Integer[] sa;&#10;    int[] rank;&#10;    int[] tmp;&#10;    int[] lcp;&#10;&#10;    int compareNode(int i, int j, int k) {&#10;        if (rank[i] != rank[j]) {&#10;            return rank[i] - rank[j];&#10;        } else {&#10;            int ri = i + k &lt;= n ? rank[i+k] : -1;&#10;            int rj = j + k &lt;= n ? rank[j+k] : -1;&#10;            return ri - rj;&#10;        }&#10;    }&#10;&#10;    public SuffixArray(char[] x) {&#10;        base = x;&#10;        n = base.length;&#10;    }&#10;&#10;    void buildSA() {&#10;        sa = new Integer[n+1];&#10;        rank = new int[n+1];&#10;        tmp = new int[n+1];&#10;        for (int i = 0 ; i &lt;= n ; i++) {&#10;            sa[i] = i;&#10;            rank[i] = (i &lt; n) ? base[i] : -1;&#10;        }&#10;        for (int _k = 1 ; _k &lt;= n ; _k *= 2) {&#10;            final int k = _k;&#10;            Arrays.sort(sa, new Comparator&lt;Integer&gt;() {&#10;                @Override&#10;                public int compare(Integer i, Integer j) {&#10;                    return compareNode(i, j, k);&#10;                }&#10;            });&#10;            tmp[sa[0]] = 0;&#10;            for (int i = 1 ; i &lt;= n ; i++) {&#10;                tmp[sa[i]] = tmp[sa[i-1]] + ((compareNode(sa[i-1], sa[i], k) &lt; 0) ? 1 : 0);&#10;            }&#10;            for (int i = 0 ; i &lt;= n ; i++) {&#10;                rank[i] = tmp[i];&#10;            }&#10;        }&#10;    }&#10;&#10;    void buildLCP() {&#10;        for (int i = 0 ; i &lt;= n ; i++) {&#10;            rank[sa[i]] = i;&#10;        }&#10;        lcp = new int[n];&#10;        int h = 0;&#10;        for (int i = 0 ; i &lt; n ; i++) {&#10;            int j = sa[rank[i]-1];&#10;            if (h &gt; 0) {&#10;                h--;&#10;            }&#10;            for (; j + h &lt; n &amp;&amp; i + h &lt; n ; h++) {&#10;                if (base[j+h] != base[i+h]) {&#10;                    break;&#10;                }&#10;            }&#10;            lcp[rank[i]-1] = h;&#10;        }&#10;    }&#10;}" description="文字列の接尾辞配列" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="tmpl" value="import java.io.IOException;&#10;import java.io.InputStream;&#10;import java.io.PrintWriter;&#10;import java.util.Arrays;&#10;import java.util.InputMismatchException;&#10;&#10;public class XXXXXX {&#10;    public static void main(String[] args) {&#10;        InputReader in = new InputReader(System.in);&#10;        PrintWriter out = new PrintWriter(System.out);&#10;&#10;        int x = in.nextInt();&#10;        out.println(x);&#10;&#10;        out.flush();&#10;    }&#10;&#10;    static class InputReader {&#10;        private InputStream stream;&#10;        private byte[] buf = new byte[1024];&#10;        private int curChar;&#10;        private int numChars;&#10;&#10;        public InputReader(InputStream stream) {&#10;            this.stream = stream;&#10;        }&#10;&#10;        private int next() {&#10;            if (numChars == -1)&#10;                throw new InputMismatchException();&#10;            if (curChar &gt;= numChars) {&#10;                curChar = 0;&#10;                try {&#10;                    numChars = stream.read(buf);&#10;                } catch (IOException e) {&#10;                    throw new InputMismatchException();&#10;                }&#10;                if (numChars &lt;= 0)&#10;                    return -1;&#10;            }&#10;            return buf[curChar++];&#10;        }&#10;&#10;        public int nextInt() {&#10;            int c = next();&#10;            while (isSpaceChar(c))&#10;                c = next();&#10;            int sgn = 1;&#10;            if (c == '-') {&#10;                sgn = -1;&#10;                c = next();&#10;            }&#10;            int res = 0;&#10;            do {&#10;                if (c &lt; '0' || c &gt; '9')&#10;                    throw new InputMismatchException();&#10;                res *= 10;&#10;                res += c - '0';&#10;                c = next();&#10;            } while (!isSpaceChar(c));&#10;            return res * sgn;&#10;        }&#10;&#10;        public long nextLong() {&#10;            int c = next();&#10;            while (isSpaceChar(c))&#10;                c = next();&#10;            long sgn = 1;&#10;            if (c == '-') {&#10;                sgn = -1;&#10;                c = next();&#10;            }&#10;            long res = 0;&#10;            do {&#10;                if (c &lt; '0' || c &gt; '9')&#10;                    throw new InputMismatchException();&#10;                res *= 10;&#10;                res += c - '0';&#10;                c = next();&#10;            } while (!isSpaceChar(c));&#10;            return res * sgn;&#10;        }&#10;&#10;        public boolean isSpaceChar(int c) {&#10;            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;&#10;        }&#10;&#10;        public interface SpaceCharFilter {&#10;            public boolean isSpaceChar(int ch);&#10;        }&#10;    }&#10;&#10;    static void debug(Object... o) {&#10;        System.err.println(Arrays.deepToString(o));&#10;    }&#10;}&#10;" description="solution template" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="tree_lca" value="static class LCA {&#10;    int[][] graph;&#10;    int[][] parent;&#10;    int[] depth;&#10;&#10;    public LCA(int[][] graph) {&#10;        int n = graph.length;&#10;        this.graph = graph;&#10;        init(n);&#10;    }&#10;&#10;    void buildDepth() {&#10;        int[] que = new int[graph.length*3+10];&#10;        int qh = 0;&#10;        int qt = 0;&#10;        que[qh++] = 0;&#10;        que[qh++] = -1;&#10;        que[qh++] = 0;&#10;        depth[0] = 0;&#10;        parent[0][0] = -1;&#10;        while (qt &lt; qh) {&#10;            int now = que[qt++];&#10;            int frm = que[qt++];&#10;            int dep = que[qt++];&#10;            for (int to : graph[now]) {&#10;                if (to != frm) {&#10;                    parent[0][to] = now;&#10;                    depth[to] = dep+1;&#10;                    que[qh++] = to;&#10;                    que[qh++] = now;&#10;                    que[qh++] = dep+1;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    void init(int n) {&#10;        int log = 1;&#10;        int nn = n;&#10;        while (nn &gt;= 1) {&#10;            nn /= 2;&#10;            log++;&#10;        }&#10;        parent = new int[log+1][n];&#10;        for (int i = 0 ; i &lt;= log ; i++) {&#10;            Arrays.fill(parent[i], -1);&#10;        }&#10;        depth = new int[n];&#10;        buildDepth();&#10;&#10;        for (int k = 0 ; k &lt; log ; k++) {&#10;            for (int v = 0 ; v &lt; n ; v++) {&#10;                if (parent[k][v] &lt; 0) {&#10;                    parent[k+1][v] = -1;&#10;                } else {&#10;                    parent[k+1][v] = parent[k][parent[k][v]];&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    int lca(int u, int v) {&#10;        int loglen = parent.length;&#10;        if (depth[u] &gt; depth[v]) {&#10;            int tmp = u;&#10;            u = v;&#10;            v = tmp;&#10;        }&#10;        for (int k = 0 ; k &lt; loglen ; k++) {&#10;            if (((depth[v] - depth[u]) &gt;&gt; k) % 2 == 1) {&#10;                v = parent[k][v];&#10;            }&#10;        }&#10;        if (u == v) {&#10;            return u;&#10;        }&#10;&#10;        for (int k = loglen-1 ; k &gt;= 0 ; k--) {&#10;            if (parent[k][u] != parent[k][v]) {&#10;                u = parent[k][u];&#10;                v = parent[k][v];&#10;            }&#10;        }&#10;        return parent[0][u];&#10;    }&#10;&#10;    int dist(int x, int y) {&#10;        int l = lca(x, y);&#10;        return depth[x] + depth[y] - depth[l] * 2;&#10;    }&#10;}&#10;" description="LCA" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="tree_lca_query" value="static class TreeLCAQuery {&#10;    LCA lca;&#10;    int[] val;&#10;    int[][] dbl;&#10;&#10;    public TreeLCAQuery(LCA lca, int[] val) {&#10;        int n = val.length;&#10;        this.lca = lca;&#10;        this.val = val;&#10;        int lg = lca.parent.length;&#10;        dbl = new int[lg][n];&#10;        for (int i = 0 ; i &lt; n ; i++) {&#10;            dbl[0][i] = val[i];&#10;        }&#10;        for (int l = 1 ; l &lt; lg ; l++) {&#10;            for (int i = 0 ; i &lt; n ; i++) {&#10;                int half = lca.parent[l-1][i];&#10;                if (half &gt;= 0) {&#10;                    dbl[l][i] = Math.min(dbl[l-1][i], dbl[l-1][half]);&#10;                } else {&#10;                    dbl[l][i] = dbl[l-1][i];&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public int min(int u, int v) {&#10;        int min = Integer.MAX_VALUE;&#10;        while (u != v) {&#10;            int diff = lca.depth[u] - lca.depth[v];&#10;            int ctr = -1;&#10;            while (diff &gt; 0) {&#10;                ctr++;&#10;                diff /= 2;&#10;            }&#10;            min = Math.min(min, dbl[ctr][u]);&#10;            u = lca.parent[ctr][u];&#10;        }&#10;        min = Math.min(min, dbl[0][u]);&#10;        return min;&#10;    }&#10;}&#10;" description="ツリー上のクエリをLCAで解く" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="unionfind" value="static class UnionFind {&#10;    int[] rank;&#10;    int[] parent;&#10;    int[] cnt;&#10;&#10;    public UnionFind(int n) {&#10;        rank = new int[n];&#10;        parent = new int[n];&#10;        cnt = new int[n];&#10;        for (int i = 0; i &lt; n ; i++) {&#10;            parent[i] = i;&#10;            cnt[i] = 1;&#10;        }&#10;    }&#10;&#10;    public int find(int a) {&#10;        if (parent[a] == a) {&#10;            return a;&#10;        }&#10;        parent[a] = find(parent[a]);&#10;        return parent[a];&#10;    }&#10;&#10;    public void unite(int a, int b) {&#10;        a = find(a);&#10;        b = find(b);&#10;        if (a == b) {&#10;            return;&#10;        }&#10;        if (rank[a] &lt; rank[b]) {&#10;            parent[a] = b;&#10;            cnt[b] += cnt[a];&#10;            cnt[a] = cnt[b];&#10;        } else {&#10;            parent[b] = a;&#10;            cnt[a] += cnt[b];&#10;            cnt[b] = cnt[a];&#10;            if (rank[a] == rank[b]) {&#10;                rank[a]++;&#10;            }&#10;        }&#10;    }&#10;&#10;    public int groupCount(int a) {&#10;        return cnt[find(a)];&#10;    }&#10;&#10;    private boolean issame(int a, int b) {&#10;        return find(a) == find(b);&#10;    }&#10;}&#10;" description="素集合データ構造" toReformat="false" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
