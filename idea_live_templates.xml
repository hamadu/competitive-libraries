<template name="combinatorics.bellnumber" value="/**&#10; * Computes Bell triangle.&#10; * ret[n][n] := Bell number of x.&#10; * ret[n][k] := The number of partitions of the set {1,2,...,n+1} s.t. k+1 is the largest singleton of the partition.&#10; *&#10; * O(n^2)&#10; *&#10; * @refs https://en.wikipedia.org/wiki/Bell_triangle#Combinatorial_interpretation&#10; * @param n&#10; * @param mod&#10; * @return&#10; */&#10;public static long[][] bellTriangle(int n, int mod) {&#10;    long[][] ret = new long[n+1][n+1];&#10;    ret[0][0] = 1;&#10;    for (int i = 1; i &lt;= n ; i++) {&#10;        ret[i][1] = ret[i-1][i-1];&#10;        for (int j = 2 ; j &lt;= i ; j++) {&#10;            ret[i][j] = (ret[i-1][j-1] + ret[i][j-1]) % mod;&#10;        }&#10;    }&#10;    for (int i = 1 ; i &lt;= n ; i++) {&#10;        ret[i][0] = (ret[i][1] - ret[i-1][0] + mod) % mod;&#10;    }&#10;    return ret;&#10;}" description="ベル数の三角形" toReformat="true" toShortenFQNames="true">
  <context>
    <option name="JAVA_DECLARATION" value="true" />
  </context>
</template>
<template name="combinatorics.combination" value="static final int MOD = 1000000007;&#10;&#10;static long pow(long a, long x) {&#10;    long res = 1;&#10;    while (x &gt; 0) {&#10;        if (x % 2 != 0) {&#10;        res = (res * a) % MOD;&#10;        }&#10;        a = (a * a) % MOD;&#10;        x /= 2;&#10;    }&#10;    return res;&#10;}&#10;&#10;static long inv(long a) {&#10;    return pow(a, MOD - 2) % MOD;&#10;}&#10;&#10;static long[] _fact;&#10;static long[] _invfact;&#10;static long comb(long ln, long lr) {&#10;    int n = (int)ln;&#10;    int r = (int)lr;&#10;    if (n &lt; 0 || r &lt; 0 || r &gt; n) {&#10;        return 0;&#10;    }&#10;    if (r &gt; n / 2) {&#10;        r = n - r;&#10;    }&#10;    return (((_fact[n] * _invfact[n - r]) % MOD) * _invfact[r]) % MOD;&#10;}&#10;&#10;static void prec(int n) {&#10;    _fact = new long[n + 1];&#10;    _invfact = new long[n + 1];&#10;    _fact[0] = 1;&#10;    _invfact[0] = 1;&#10;    for (int i = 1; i &lt;= n; i++) {&#10;        _fact[i] = _fact[i - 1] * i % MOD;&#10;        _invfact[i] = inv(_fact[i]);&#10;    }&#10;}&#10;" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="combinatorics.permutation" value="/**&#10; * Computes smallest lexicographically larger permutation of given array.&#10; * Modifies given array directly.&#10; * If there is no such permutation, returns false.&#10; *&#10; * @param a&#10; * @return&#10; *&#10; */&#10;public static boolean next_permutation(int[] a) {&#10;    int len = a.length;&#10;    int x = len - 2;&#10;    while (x &gt;= 0 &amp;&amp; a[x] &gt;= a[x+1]) {&#10;        x--;&#10;    }&#10;    if (x == -1) {&#10;        return false;&#10;    }&#10;&#10;    int y = len - 1;&#10;    while (y &gt; x &amp;&amp; a[y] &lt;= a[x]) {&#10;        y--;&#10;    }&#10;    int tmp = a[x];&#10;    a[x] = a[y];&#10;    a[y] = tmp;&#10;    Arrays.sort(a, x+1, len);&#10;    return true;&#10;}&#10;" description="順列の列挙" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="combinatorics.stirlingnumber" value="/**&#10; * Computes Stirling number of 1st kind up to n.&#10; * ret[n][k] means number of ways to split n labeled items into k alternating-sequences.&#10; *&#10; * @param n&#10; * @param mod&#10; * @return&#10; *&#10; */&#10;public static long[][] stirlingFirst(int n, long mod) {&#10;    long[][] ret = new long[n+1][n+1];&#10;    ret[0][0] = 1;&#10;    for (int i = 1 ; i &lt;= n ; i++) {&#10;        for (int j = 1 ; j &lt;= i ; j++) {&#10;            ret[i][j] += ret[i-1][j-1];&#10;            ret[i][j] += ret[i-1][j] * (i-1);&#10;            ret[i][j] %= mod;&#10;        }&#10;    }&#10;    return ret;&#10;}&#10;&#10;/**&#10; * Computes Stirling number of 2nd kind up to n.&#10; * ret[n][k] means number of ways to split n labeled items into k non-empty groups.&#10; *&#10; * @param n&#10; * @param mod&#10; * @return&#10; *&#10; */&#10;public static long[][] stirlingSecond(int n, long mod) {&#10;    long[][] ret = new long[n+1][n+1];&#10;    ret[0][0] = 1;&#10;    for (int i = 1 ; i &lt;= n ; i++) {&#10;        for (int j = 1 ; j &lt;= i ; j++) {&#10;            ret[i][j] += ret[i-1][j-1];&#10;            ret[i][j] += ret[i-1][j] * j;&#10;            ret[i][j] %= mod;&#10;        }&#10;    }&#10;    return ret;&#10;}&#10;" description="スターリング数(第一種,第二種)" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="combinatorics.subset" value="/**&#10; * Iterate subsets of X.&#10; *&#10; * @param X&#10; * @param dp&#10; */&#10;public static void subset(int X, int[] dp) {&#10;    for (int sub = (X - 1) &amp; X ; sub &gt; 0 ; sub = (sub - 1) &amp; X) {&#10;        dp[X] = Math.max(dp[X], dp[sub] + dp[X^sub]);&#10;    }&#10;}&#10;" description="部分集合の列挙" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="count_distinct_value_in_array" value="static class Event implements Comparable&lt;Event&gt; {&#10;    int fr;&#10;    int to;&#10;    int val;  // plus: array value, 0 or minus: -(query index)&#10;&#10;    Event(int f, int t, int ty) {&#10;        fr = f;&#10;        to = t;&#10;        val = ty;&#10;    }&#10;&#10;    @Override&#10;    public int compareTo(Event o) {&#10;        if (fr != o.fr) {&#10;            return o.fr - fr;&#10;        }&#10;        return o.val - val;&#10;    }&#10;}&#10;&#10;static int[] countDistinctValues(int[] arr, int[][] query) {&#10;    int q = query.length;&#10;    int n = arr.length;&#10;&#10;    BIT bit = new BIT(n+5);&#10;&#10;    Event[] events = new Event[q+n];&#10;    for (int i = 0; i &lt; q ; i++) {&#10;        events[i] = new Event(query[i][0], query[i][1], -i);&#10;    }&#10;    for (int i = 0; i &lt; n ; i++) {&#10;        events[q+i] = new Event(i, i, arr[i]+1);&#10;    }&#10;    Arrays.sort(events);&#10;&#10;    int[] ret = new int[q];&#10;    int max = 0;&#10;    for (int i = 0; i &lt; arr.length ; i++) {&#10;        max = Math.max(max, arr[i]);&#10;    }&#10;    int[] lastFound = new int[max+10];&#10;    for (Event e : events) {&#10;        if (e.val &lt;= 0) {&#10;            int qidx = -e.val;&#10;            ret[qidx] = (int)bit.range(e.fr+1, e.to+1);&#10;        } else {&#10;            if (lastFound[e.val] != 0) {&#10;                bit.add(lastFound[e.val], -1);&#10;            }&#10;            bit.add(e.fr+1, 1);&#10;            lastFound[e.val] = e.fr+1;&#10;        }&#10;    }&#10;    return ret;&#10;}" description="配列中、指定範囲に数が何種類存在するか調べる" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="dp.limited_knapsack" value="/**&#10; * Item-answerCountQuery-limited knapsack.&#10; * O(nW)&#10; *&#10; * @param dp   dp value&#10; * @param item array of item({value, weight, limit})&#10; * @param maxW quota of the knapsack&#10; */&#10;static void itemLimitedKnapsack(int[] dp, int[][] item, int maxW) {&#10;    int[] deqIdx = new int[maxW+1];&#10;    int[] deqVal = new int[maxW+1];&#10;    int n = item.length;&#10;    for (int i = 0; i &lt; n ; i++) {&#10;        int v = item[i][0]; // value&#10;        int w = item[i][1]; // weight&#10;        int m = item[i][2]; // limit&#10;        for (int a = 0 ; a &lt; w ; a++) {&#10;            int s = 0;&#10;            int t = 0;&#10;            for (int j = 0; j * w + a &lt;= maxW ; j++) {&#10;                int val = dp[j * w + a] - j * v;&#10;                while (s &lt; t &amp;&amp; deqVal[t-1] &lt;= val) {&#10;                    t--;&#10;                }&#10;                deqIdx[t] = j;&#10;                deqVal[t] = val;&#10;                t++;&#10;                dp[j * w + a] = Math.max(dp[j * w + a], deqVal[s] + j * v);&#10;                if (deqIdx[s] == j - m) {&#10;                    s++;&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" description="個数制限ナップサック" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="dp.lis" value="/**&#10; * Computes longest increasing sequence.&#10; * If you want to get actual sequence, see dp[1..ans].&#10; *&#10; * O(nlogn)&#10; *&#10; * @param values&#10; * @return&#10; */&#10;public static int lis(int[] values) {&#10;    int n = values.length;&#10;    long[] lval = new long[n];&#10;    for (int i = 0; i &lt; values.length; i++) {&#10;        lval[i] = values[i]*1000000000L+i;&#10;    }&#10;    int ans = 0;&#10;    long[] dp = new long[n+1];&#10;    Arrays.fill(dp, Long.MIN_VALUE);&#10;    for (int i = 0; i &lt; n; i++) {&#10;        int idx = Arrays.binarySearch(dp, 0, ans+1, lval[i]);&#10;        if (idx &lt; 0) {&#10;            idx = -idx-2;&#10;            dp[idx+1] = lval[i];&#10;            if (idx &gt;= ans) {&#10;                ans++;&#10;            }&#10;        }&#10;    }&#10;    return ans;&#10;}&#10;" description="Longest Increasing Sequence" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="ds.fenwick_tree" value="public class FenwickTree {&#10;    long N;&#10;    long[] data;&#10;&#10;    public FenwickTree(int n) {&#10;        N = n;&#10;        data = new long[n+1];&#10;    }&#10;&#10;    /**&#10;     * Computes value of [1, i].&#10;     *&#10;     * O(logn)&#10;     *&#10;     * @param i&#10;     * @return&#10;     */&#10;    public long sum(int i) {&#10;        long s = 0;&#10;        while (i &gt; 0) {&#10;            s += data[i];&#10;            i -= i &amp; (-i);&#10;        }&#10;        return s;&#10;    }&#10;&#10;    /**&#10;     * Computes value of [i, j].&#10;     *&#10;     * O(logn)&#10;     *&#10;     * @param i&#10;     * @param j&#10;     * @return&#10;     */&#10;    public long range(int i, int j) {&#10;        return sum(j) - sum(i-1);&#10;    }&#10;&#10;    /**&#10;     * Sets value x into i-th position.&#10;     *&#10;     * O(logn)&#10;     *&#10;     * @param i&#10;     * @param x&#10;     */&#10;    public void set(int i, long x) {&#10;        add(i, x-range(i, i));&#10;    }&#10;&#10;    /**&#10;     * Adds value x into i-th position.&#10;     *&#10;     * O(logn)&#10;     *&#10;     * @param i&#10;     * @param x&#10;     */&#10;    public void add(int i, long x) {&#10;        while (i &lt;= N) {&#10;            data[i] += x;&#10;            i += i &amp; (-i);&#10;        }&#10;    }&#10;}" description="Fenwick Tree (also known as BIT)" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="ds.heap.minheap" value="import java.util.Arrays;&#10;&#10;public class MinHeap {&#10;    private static final long INF = Long.MAX_VALUE;&#10;&#10;    int pos;&#10;    long[] data;&#10;&#10;    public MinHeap(int capacity) {&#10;        data = new long[capacity];&#10;        pos = 1;&#10;        Arrays.fill(data, INF);&#10;&#10;    }&#10;&#10;    public void push(long x) {&#10;        int p = pos;&#10;        data[pos++] = x;&#10;        while (p != 1) {&#10;            int pp = p&gt;&gt;&gt;1;&#10;            if (data[pp] &lt;= data[p]) {&#10;                break;&#10;            }&#10;            long tmp = data[pp];&#10;            data[pp] = data[p];&#10;            data[p] = tmp;&#10;            p = pp;&#10;        }&#10;    }&#10;&#10;    public long peek() {&#10;        return data[1];&#10;    }&#10;&#10;    public long poll() {&#10;        if (size() == 0) {&#10;            throw new RuntimeException(&quot;queue is empty&quot;);&#10;        }&#10;        pos--;&#10;        long ret = data[1];&#10;        data[1] = data[pos];&#10;        data[pos] = INF;&#10;&#10;        for (int p = 1 ; p * 2 &lt; pos ; ){&#10;            int l = p&lt;&lt;1;&#10;            int r = l+1;&#10;            int to = data[l] &lt; data[r] ? l : r;&#10;            if (data[to] &lt; data[p]) {&#10;                long tmp = data[to];&#10;                data[to] = data[p];&#10;                data[p] = tmp;&#10;                p = to;&#10;            } else {&#10;                break;&#10;            }&#10;        }&#10;        return ret;&#10;    }&#10;&#10;    public int size() {&#10;        return pos-1;&#10;    }&#10;}" description="最小値ヒープ" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="ds.heap.skewheapint" value="/**&#10; * Meldable heap.&#10; */&#10;public class SkewHeapInt {&#10;    static class Node {&#10;        Node l, r;&#10;        int value;&#10;&#10;        public Node(int v) {&#10;            value = v;&#10;        }&#10;    }&#10;&#10;    Node root;&#10;    int size;&#10;&#10;    public int size() {&#10;        return size;&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return root == null;&#10;    }&#10;&#10;    public void push(int v) {&#10;        size++;&#10;        root = meld(root, new Node(v));&#10;    }&#10;&#10;    public int peek() {&#10;        return root.value;&#10;    }&#10;&#10;    public int pop() {&#10;        size--;&#10;        int ret = peek();&#10;        root = meld(root.r, root.l);&#10;        return ret;&#10;    }&#10;&#10;    public void clear() {&#10;        root = null;&#10;        size = 0;&#10;    }&#10;&#10;    public SkewHeapInt meld(SkewHeapInt other) {&#10;        return meld(this, other);&#10;    }&#10;&#10;    public static SkewHeapInt meld(SkewHeapInt a, SkewHeapInt b) {&#10;        Node newRoot = meld(a.root, b.root);&#10;        SkewHeapInt newHeap = new SkewHeapInt();&#10;        newHeap.root = newRoot;&#10;        newHeap.size = a.size + b.size;&#10;        return newHeap;&#10;    }&#10;&#10;    public static Node meld(Node a, Node b) {&#10;        if (a == null) {&#10;            return b;&#10;        }&#10;        if (b == null) {&#10;            return a;&#10;        }&#10;        if (a.value &gt; b.value) {&#10;            Node tmp = a;&#10;            a = b;&#10;            b = tmp;&#10;        }&#10;        a.r = meld(a.r, b);&#10;        Node tmp = a.l;&#10;        a.l = a.r;&#10;        a.r = tmp;&#10;        return a;&#10;    }&#10;}&#10;" description="Implementation of meldable heap" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="ds.heap.treapfindint" value="import utils.rand.XorShift;&#10;&#10;/**&#10; * Treap(tree+heap)&#10; */&#10;public class TreapFindInt {&#10;    private static final int INF = 100000001;&#10;&#10;    static XorShift rand = new XorShift();&#10;&#10;    static class Node {&#10;        Node l, r;&#10;        int value;&#10;        int count;&#10;        int heapValue;&#10;&#10;        public Node(int v) {&#10;            value = v;&#10;            heapValue = rand.next();&#10;            count = 1;&#10;        }&#10;    }&#10;&#10;    Node root;&#10;&#10;&#10;&#10;    public static Node update(Node a) {&#10;        if (a == null) {&#10;            return null;&#10;        }&#10;        a.count = 1 + count(a.l) + count(a.r);&#10;        return a;&#10;    }&#10;&#10;    public static int count(Node a) {&#10;        return (a == null) ? 0 : a.count;&#10;    }&#10;&#10;&#10;    /**&#10;     * Finds node position that value = v.&#10;     * If there is no such node, returns minus value.&#10;     *&#10;     * @param v&#10;     * @return found node.&#10;     */&#10;    public static int detect(Node x, int v) {&#10;        if (x == null) {&#10;            return -INF;&#10;        }&#10;        if (x.value == v) {&#10;            return count(x.l);&#10;        } else if (v &lt; x.value) {&#10;            return detect(x.l, v);&#10;        } else {&#10;            return count(x.l) + 1 + detect(x.r, v);&#10;        }&#10;    }&#10;&#10;&#10;    /**&#10;     * Merges two trees.&#10;     *&#10;     * @param a&#10;     * @param b&#10;     * @return merged root node&#10;     */&#10;    public static Node merge(Node a, Node b) {&#10;        if (a == null || b == null) {&#10;            return a == null ? b : a;&#10;        }&#10;        if (a.heapValue &lt; b.heapValue) {&#10;            a.r = merge(a.r, b);&#10;            return update(a);&#10;        } else {&#10;            b.l = merge(a, b.l);&#10;            return update(b);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Splits tree at point k. [0, k), [k, n)&#10;     *&#10;     * @param a&#10;     * @param k&#10;     * @return&#10;     */&#10;    public static Node[] split(Node a, int k) {&#10;        if (a == null) {&#10;            return new Node[]{null, null};&#10;        }&#10;        if (k &lt;= count(a.l)) {&#10;            Node[] s = split(a.l, k);&#10;            a.l = s[1];&#10;            return new Node[]{s[0], update(a)};&#10;        } else {&#10;            Node[] s = split(a.r, k - count(a.l) - 1);&#10;            a.r = s[0];&#10;            return new Node[]{update(a), s[1]};&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Inserts node v at point k.&#10;     *&#10;     * @param a&#10;     * @param k&#10;     * @return new tree&#10;     */&#10;    public static Node insert(Node a, int k, Node v) {&#10;        Node[] x = split(a, k);&#10;        return merge(x[0], merge(v, x[1]));&#10;    }&#10;&#10;    /**&#10;     * Erases node at point k.&#10;     *&#10;     * @param a&#10;     * @param k&#10;     * @return new tree&#10;     */&#10;    public static Node erase(Node a, int k) {&#10;        Node[] al = split(a, k);&#10;        Node[] ar = split(al[1], 1);&#10;        return merge(al[0], ar[1]);&#10;    }&#10;&#10;    /**&#10;     * Returns size of the tree.&#10;     *&#10;     * @return size of the tree&#10;     */&#10;    public int size() {&#10;        return count(root);&#10;    }&#10;&#10;    /**&#10;     * Adds new node to tree.&#10;     *&#10;     * @param v&#10;     */&#10;    public void push(int v) {&#10;        root = insert(root, INF, new Node(v));&#10;    }&#10;&#10;    /**&#10;     * Finds node position that value = v.&#10;     * If there is no such node, returns minus value.&#10;     *&#10;     * @param v&#10;     * @return&#10;     */&#10;    public int detect(int v) {&#10;        return detect(root, v);&#10;    }&#10;&#10;    /**&#10;     * Removes a node value = v from tree.&#10;     *&#10;     * @param v&#10;     */&#10;    public void remove(int v) {&#10;        int pos = detect(v);&#10;        if (pos &gt;= 0) {&#10;            root = erase(root, pos);&#10;        }&#10;    }&#10;}&#10;" description="値の検索をするTreap" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="ds.heap.treapint" value="import utils.rand.XorShift;&#10;&#10;/**&#10; * Treap(tree+heap)&#10; */&#10;public class TreapInt {&#10;    private static final int INF = 100000001;&#10;&#10;    static XorShift rand = new XorShift();&#10;&#10;    static class Node {&#10;        Node l, r;&#10;        int value;&#10;        int count;&#10;        int heapValue;&#10;&#10;        public Node(int v) {&#10;            value = v;&#10;            heapValue = rand.next();&#10;            count = 1;&#10;        }&#10;    }&#10;&#10;    Node root;&#10;&#10;&#10;&#10;    public static Node update(Node a) {&#10;        if (a == null) {&#10;            return null;&#10;        }&#10;        a.count = 1 + count(a.l) + count(a.r);&#10;        return a;&#10;    }&#10;&#10;    public static int count(Node a) {&#10;        return (a == null) ? 0 : a.count;&#10;    }&#10;&#10;    /**&#10;     * Grabs k-th node from given node.&#10;     *&#10;     * @param a&#10;     * @param k&#10;     * @return&#10;     */&#10;    public static Node grab(Node a, int k) {&#10;        if (a == null) {&#10;            return null;&#10;        }&#10;        update(a);&#10;        int l = count(a.l);&#10;        if (k == l) {&#10;            return a;&#10;        } else if (k &lt; l) {&#10;            return grab(a.l, k);&#10;        } else {&#10;            return grab(a.r, k-l-1);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Merges two trees.&#10;     *&#10;     * @param a&#10;     * @param b&#10;     * @return merged root node&#10;     */&#10;    public static Node merge(Node a, Node b) {&#10;        if (a == null || b == null) {&#10;            return a == null ? b : a;&#10;        }&#10;        if (a.heapValue &lt; b.heapValue) {&#10;            a.r = merge(a.r, b);&#10;            return update(a);&#10;        } else {&#10;            b.l = merge(a, b.l);&#10;            return update(b);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Splits tree at point k. [0, k), [k, n)&#10;     *&#10;     * @param a&#10;     * @param k&#10;     * @return&#10;     */&#10;    public static Node[] split(Node a, int k) {&#10;        if (a == null) {&#10;            return new Node[]{null, null};&#10;        }&#10;        if (k &lt;= count(a.l)) {&#10;            Node[] s = split(a.l, k);&#10;            a.l = s[1];&#10;            return new Node[]{s[0], update(a)};&#10;        } else {&#10;            Node[] s = split(a.r, k - count(a.l) - 1);&#10;            a.r = s[0];&#10;            return new Node[]{update(a), s[1]};&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Inserts node v at point k.&#10;     *&#10;     * @param a&#10;     * @param k&#10;     * @return new tree&#10;     */&#10;    public static Node insert(Node a, int k, Node v) {&#10;        Node[] x = split(a, k);&#10;        return merge(x[0], merge(v, x[1]));&#10;    }&#10;&#10;    /**&#10;     * Erases node at point k.&#10;     *&#10;     * @param a&#10;     * @param k&#10;     * @return new tree&#10;     */&#10;    public static Node erase(Node a, int k) {&#10;        Node[] al = split(a, k);&#10;        Node[] ar = split(al[1], 1);&#10;        return merge(al[0], ar[1]);&#10;    }&#10;&#10;    /**&#10;     * Returns size of the tree.&#10;     *&#10;     * @return size of the tree&#10;     */&#10;    public int size() {&#10;        return count(root);&#10;    }&#10;&#10;    /**&#10;     * Adds new node value=v to the end of tree.&#10;     *&#10;     * @param v&#10;     */&#10;    public void push(int v) {&#10;        root = insert(root, INF, new Node(v));&#10;    }&#10;&#10;    /**&#10;     * Adds new node value=v to tree at k-th position.&#10;     *&#10;     * @param v&#10;     */&#10;    public void push(int v, int k) {&#10;        root = insert(root, k, new Node(v));&#10;    }&#10;&#10;    /**&#10;     * Removes k-th node from tree.&#10;     *&#10;     * @param k&#10;     */&#10;    public void remove(int k) {&#10;        root = erase(root, k);&#10;    }&#10;&#10;    /**&#10;     * Get k-th node value&#10;     *&#10;     * @param k&#10;     * @return&#10;     */&#10;    public int get(int k) {&#10;        Node n = grab(root, k);&#10;        if (n == null) {&#10;            return -INF;&#10;        }&#10;        return n.value;&#10;    }&#10;}&#10;" description="場所を指定して値を挿入・削除できるTreap" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="ds.heap.treapintrev" value="import utils.rand.XorShift;&#10;&#10;/**&#10; * Treap(tree+heap). Reversable.&#10; */&#10;public class TreapIntRev {&#10;    private static final int INF = 100000001;&#10;&#10;    static XorShift rand = new XorShift();&#10;&#10;    static class Node {&#10;        Node l, r;&#10;        int value;&#10;        int count;&#10;        int heapValue;&#10;        boolean reversed;&#10;&#10;        public Node(int v) {&#10;            value = v;&#10;            heapValue = rand.next();&#10;            count = 1;&#10;        }&#10;&#10;        public void print(String prefix) {&#10;            if (l != null) {&#10;                l.print(prefix + &quot; &quot;);&#10;            }&#10;            System.out.println(prefix + &quot;v=&quot;+value+&quot;/r=&quot;+reversed);&#10;            if (r != null) {&#10;                r.print(prefix + &quot; &quot;);&#10;            }&#10;        }&#10;&#10;    }&#10;&#10;    Node root;&#10;&#10;    public static Node update(Node a) {&#10;        if (a == null) {&#10;            return null;&#10;        }&#10;        pushDown(a);&#10;        a.count = 1 + count(a.l) + count(a.r);&#10;        return a;&#10;    }&#10;&#10;    public static void pushDown(Node a) {&#10;        if (a.reversed) {&#10;            Node tmp = a.l;&#10;            a.l = a.r;&#10;            a.r = tmp;&#10;            reverse(a.l);&#10;            reverse(a.r);&#10;            a.reversed = false;&#10;        }&#10;    }&#10;&#10;    public static int count(Node a) {&#10;        return (a == null) ? 0 : a.count;&#10;    }&#10;&#10;    public static void reverse(Node a) {&#10;        if (a != null) {&#10;            a.reversed ^= true;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Grabs k-th node from given node.&#10;     *&#10;     * @param a&#10;     * @param k&#10;     * @return&#10;     */&#10;    public static Node grab(Node a, int k) {&#10;        if (a == null) {&#10;            return null;&#10;        }&#10;        update(a);&#10;        int l = count(a.l);&#10;        if (k == l) {&#10;            return a;&#10;        } else if (k &lt; l) {&#10;            return grab(a.l, k);&#10;        } else {&#10;            return grab(a.r, k-l-1);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Merges two trees.&#10;     *&#10;     * @param a&#10;     * @param b&#10;     * @return merged root node&#10;     */&#10;    public static Node merge(Node a, Node b) {&#10;        if (a == null || b == null) {&#10;            return a == null ? b : a;&#10;        }&#10;        update(a);&#10;        update(b);&#10;        if (a.heapValue &lt; b.heapValue) {&#10;            a.r = merge(a.r, b);&#10;            return update(a);&#10;        } else {&#10;            b.l = merge(a, b.l);&#10;            return update(b);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Splits tree at point k. [0, k), [k, n)&#10;     *&#10;     * @param a&#10;     * @param k&#10;     * @return&#10;     */&#10;    public static Node[] split(Node a, int k) {&#10;        if (a == null) {&#10;            return new Node[]{null, null};&#10;        }&#10;        update(a);&#10;        if (k &lt;= count(a.l)) {&#10;            Node[] s = split(a.l, k);&#10;            a.l = s[1];&#10;            return new Node[]{s[0], update(a)};&#10;        } else {&#10;            Node[] s = split(a.r, k - count(a.l) - 1);&#10;            a.r = s[0];&#10;            return new Node[]{update(a), s[1]};&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Inserts node v at point k.&#10;     *&#10;     * @param a&#10;     * @param k&#10;     * @return new tree&#10;     */&#10;    public static Node insert(Node a, int k, Node v) {&#10;        Node[] x = split(a, k);&#10;        return merge(x[0], merge(v, x[1]));&#10;    }&#10;&#10;    /**&#10;     * Erases node at point k.&#10;     *&#10;     * @param a&#10;     * @param k&#10;     * @return new tree&#10;     */&#10;    public static Node erase(Node a, int k) {&#10;        Node[] al = split(a, k);&#10;        Node[] ar = split(al[1], 1);&#10;        return merge(al[0], ar[1]);&#10;    }&#10;&#10;&#10;    /**&#10;     * Reverses value at point [l, r)&#10;     *&#10;     * @param l&#10;     * @param r&#10;     */&#10;    public void reverse(int l, int r) {&#10;        Node[] right = split(root, r);&#10;        Node[] left = split(right[0], l);&#10;        reverse(left[1]);&#10;        root = merge(left[0], merge(left[1], right[1]));&#10;    }&#10;&#10;    /**&#10;     * Returns size of the tree.&#10;     *&#10;     * @return size of the tree&#10;     */&#10;    public int size() {&#10;        return count(root);&#10;    }&#10;&#10;    /**&#10;     * Adds new node value=v to the end of tree.&#10;     *&#10;     * @param v&#10;     */&#10;    public void push(int v) {&#10;        root = insert(root, INF, new Node(v));&#10;    }&#10;&#10;    /**&#10;     * Adds new node value=v to tree at k-th position.&#10;     *&#10;     * @param v&#10;     */&#10;    public void push(int v, int k) {&#10;        root = insert(root, k, new Node(v));&#10;    }&#10;&#10;    /**&#10;     * Removes k-th node from tree.&#10;     *&#10;     * @param k&#10;     */&#10;    public void remove(int k) {&#10;        root = erase(root, k);&#10;    }&#10;&#10;    /**&#10;     * Get k-th node value&#10;     *&#10;     * @param k&#10;     * @return&#10;     */&#10;    public int get(int k) {&#10;        Node n = grab(root, k);&#10;        if (n == null) {&#10;            return -INF;&#10;        }&#10;        return n.value;&#10;    }&#10;}&#10;" description="値の反転ができるtreap" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="ds.rbst_lazy_persistent" value="static class Node {&#10;    static  Random _rnd = new Random(1);&#10;&#10;    Node left, right;&#10;    long value;&#10;    long lazyValue;&#10;    long sum;&#10;    int count;&#10;&#10;    public Node(long v) {&#10;        value = v;&#10;        lazyValue = 0;&#10;        Node.update(this);&#10;    }&#10;&#10;    public Node clone() {&#10;        Node n = new Node(value);&#10;        n.left = left;&#10;        n.right = right;&#10;        n.lazyValue = lazyValue;&#10;        return update(n);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        StringBuilder builder = new StringBuilder();&#10;        builder.append(&quot;Node [value=&quot;);&#10;        builder.append(value);&#10;        builder.append(&quot;, count=&quot;);&#10;        builder.append(count);&#10;        builder.append(&quot;, plus=&quot;);&#10;        builder.append(lazyValue);&#10;        builder.append(&quot;, sum=&quot;);&#10;        builder.append(sum);&#10;        builder.append(&quot;]&quot;);&#10;        return builder.toString();&#10;    }&#10;&#10;&#10;    static Node update(Node c) {&#10;        if (c == null) {&#10;            return null;&#10;        }&#10;        c.count = 1 + count(c.left) + count(c.right);&#10;        c.sum = c.value + count(c) * c.lazyValue + sum(c.left) + sum(c.right);&#10;        return c;&#10;    }&#10;&#10;    static Node propergate(Node c) {&#10;        if (c == null) {&#10;            return null;&#10;        }&#10;        if (c.lazyValue == 0) {&#10;            return c.clone();&#10;        }&#10;        Node nc = c.clone();&#10;        if (nc.left != null) {&#10;            nc.left = c.left.clone();&#10;            nc.left.lazyValue += c.lazyValue;&#10;            update(nc.left);&#10;        }&#10;        if (nc.right != null) {&#10;            nc.right = c.right.clone();&#10;            nc.right.lazyValue += c.lazyValue;&#10;            update(nc.right);&#10;        }&#10;        nc.value += nc.lazyValue;&#10;        nc.lazyValue = 0;&#10;        return update(nc);&#10;    }&#10;&#10;    static int count(Node c) {&#10;        return c == null ? 0 : c.count;&#10;    }&#10;&#10;    static long sum(Node c) {&#10;        return c == null ? 0 : c.sum;&#10;    }&#10;&#10;&#10;    static Node merge(Node a, Node b) {&#10;        if (a == null) {&#10;            return b;&#10;        }&#10;        if (b == null) {&#10;            return a;&#10;        }&#10;        Node ac = propergate(a);&#10;        Node bc = propergate(b);&#10;        if (_rnd.nextInt(a.count + b.count) &lt; a.count) {&#10;            ac.right = merge(a.right, bc);&#10;            return update(ac);&#10;        } else {&#10;            bc.left = merge(ac, bc.left);&#10;            return update(bc);&#10;        }&#10;    }&#10;&#10;    static Node[] split(Node c, int k) {&#10;        if (c == null) {&#10;            return new Node[2];&#10;        }&#10;        if (k &lt;= count(c.left)) {&#10;            Node cc = propergate(c);&#10;            Node[] s = split(cc.left, k);&#10;            cc.left = s[1];&#10;            s[1] = update(cc);&#10;            return s;&#10;        } else {&#10;            Node cc = propergate(c);&#10;            Node[] s = split(cc.right, k - count(cc.left) - 1);&#10;            cc.right = s[0];&#10;            s[0] = update(cc);&#10;            return s;&#10;        }&#10;    }&#10;&#10;    public static Node add(Node a, int l, int r, int v) {&#10;        if(a == null || r &lt;= 0 || count(a) &lt;= l) {&#10;            return a;&#10;        }&#10;        if(l &lt;= 0 &amp;&amp; count(a) &lt;= r) {&#10;            propergate(a);&#10;            Node ac = a.clone();&#10;            ac.lazyValue += v;&#10;            return update(ac);&#10;        }else{&#10;            propergate(a);&#10;            Node ac = a.clone();&#10;            if(0 &lt; r &amp;&amp; l &lt; count(a.left)) {&#10;                ac.left = add(a.left, l, r, v);&#10;            }&#10;            if(count(a.left)+1 &lt; r &amp;&amp; l &lt; count(a)) {&#10;                ac.right = add(a.right, l-count(a.left)-1, r-count(a.left)-1, v);&#10;            }&#10;            if(l &lt;= count(a.left) &amp;&amp; count(a.left) &lt; r){&#10;                ac.value += v;&#10;            }&#10;            return update(ac);&#10;        }&#10;    }&#10;&#10;    public static long sum(Node a, int l, int r) {&#10;        if(a == null || r &lt;= 0 || count(a) &lt;= l) {&#10;            return 0;&#10;        }&#10;        if(l &lt;= 0 &amp;&amp; count(a) &lt;= r) {&#10;            return a.sum;&#10;        } else {&#10;            long ret = 0;&#10;            if(0 &lt; r &amp;&amp; l &lt; count(a.left)) {&#10;                ret += sum(a.left, l, r);&#10;            }&#10;            if(count(a.left)+1 &lt; r &amp;&amp; l &lt; count(a)) {&#10;                ret += sum(a.right, l-count(a.left)-1, r-count(a.left)-1);&#10;            }&#10;            if(l &lt;= count(a.left) &amp;&amp; count(a.left) &lt; r){&#10;                ret += a.value;&#10;            }&#10;            ret += a.lazyValue * (Math.min(r, count(a)) - Math.max(0, l));&#10;            return ret;&#10;        }&#10;    }&#10;}&#10;" description="永続遅延評価平衡二分探索木" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="ds.segment.purmp" value="import java.util.Arrays;&#10;&#10;/**&#10; * Segment tree (point update, range minimum query)&#10; */&#10;public class SegmentTreePURMQ {&#10;    int N;&#10;    int M;&#10;    int[] seg;&#10;&#10;    public SegmentTreePURMQ(int[] data) {&#10;        N = Integer.highestOneBit(data.length-1)&lt;&lt;2;&#10;        M = (N &gt;&gt; 1) - 1;&#10;&#10;        seg = new int[N];&#10;        Arrays.fill(seg, Integer.MAX_VALUE);&#10;        for (int i = 0 ; i &lt; data.length ; i++) {&#10;            seg[M+i] = data[i];&#10;        }&#10;        for (int i = M-1 ; i &gt;= 0 ; i--) {&#10;            seg[i] = compute(i);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Uodates value at position minIndexSum.&#10;     *&#10;     * @param idx&#10;     * @param value&#10;     */&#10;    public void update(int idx, int value) {&#10;        seg[M+idx] = value;&#10;        int i = M+idx;&#10;        while (true) {&#10;            i = (i-1) &gt;&gt; 1;&#10;            seg[i] = compute(i);&#10;            if (i == 0) {&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    private int compute(int i) {&#10;        return Math.min(seg[i*2+1], seg[i*2+2]);&#10;    }&#10;&#10;    /**&#10;     * Finds minimum value from range [l,r).&#10;     *&#10;     * @param l&#10;     * @param r&#10;     * @return minimum value&#10;     */&#10;    public int min(int l, int r) {&#10;        return min(l, r, 0, 0, M+1);&#10;    }&#10;&#10;    private int min(int l, int r, int idx, int fr, int to) {&#10;        if (to &lt;= l || r &lt;= fr) {&#10;            return Integer.MAX_VALUE;&#10;        }&#10;        if (l &lt;= fr &amp;&amp; to &lt;= r) {&#10;            return seg[idx];&#10;        }&#10;&#10;        int med = (fr+to) / 2;&#10;        int ret = Integer.MAX_VALUE;&#10;        ret = Math.min(ret, min(l, r, idx*2+1, fr, med));&#10;        ret = Math.min(ret, min(l, r, idx*2+2, med, to));&#10;        return ret;&#10;    }&#10;&#10;    public int findIndexLessThanV(int l, int r, int v) {&#10;        int ret = findIndexLessThanV(l, r, 0, 0, M+1, v);&#10;        if (ret == Integer.MAX_VALUE) {&#10;            return -1;&#10;        }&#10;        return ret;&#10;    }&#10;&#10;    private int findIndexLessThanV(int l, int r, int idx, int fr, int to, int v) {&#10;        if (to &lt;= l || r &lt;= fr) {&#10;            return Integer.MAX_VALUE;&#10;        }&#10;&#10;        if (seg[idx] &gt; v) {&#10;            return Integer.MAX_VALUE;&#10;        }&#10;&#10;        int med = (fr+to) / 2;&#10;        if (l &lt;= fr &amp;&amp; to &lt;= r) {&#10;            int len = to-fr;&#10;            if (len == 1) {&#10;                return idx-M;&#10;            }&#10;        }&#10;&#10;        int left = findIndexLessThanV(l, r, idx*2+1, fr, med, v);&#10;        if (left &lt; Integer.MAX_VALUE) {&#10;            return left;&#10;        } else {&#10;            return findIndexLessThanV(l, r, idx*2+2, med, to, v);&#10;        }&#10;    }&#10;}" description="点更新・区間最小値" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="ds.segment.rarmq" value="package data_structure.segment;&#10;&#10;import java.util.Arrays;&#10;&#10;/**&#10; * Segment tree (range add, range minimum query).&#10; */&#10;public class SegmentTreeRARMQ {&#10;    int N;&#10;    int M;&#10;    long[] segMin;&#10;    long[] segAdd;&#10;&#10;    public SegmentTreeRARMQ(long[] data) {&#10;        N = Integer.highestOneBit(data.length-1)&lt;&lt;2;&#10;        M = (N &gt;&gt; 1) - 1;&#10;&#10;        segMin = new long[N];&#10;        segAdd = new long[N];&#10;        Arrays.fill(segMin, Long.MAX_VALUE);&#10;        for (int i = 0 ; i &lt; data.length ; i++) {&#10;            segMin[M+i] = data[i];&#10;        }&#10;        for (int i = M-1 ; i &gt;= 0 ; i--) {&#10;            segMin[i] = compute(i);&#10;        }&#10;    }&#10;&#10;    public long compute(int i) {&#10;        return Math.min(segMin[i*2+1], segMin[i*2+2]) + segAdd[i];&#10;    }&#10;&#10;    public void add(int l, int r, long k) {&#10;        add(l, r, k, 0, 0, M+1);&#10;    }&#10;&#10;    public void add(int l, int r, long x, int idx, int fr, int to) {&#10;        if (to &lt;= l || r &lt;= fr) {&#10;            return;&#10;        }&#10;        if (l &lt;= fr &amp;&amp; to &lt;= r) {&#10;            segAdd[idx] += x;&#10;            while (idx &gt;= 1) {&#10;                idx = (idx - 1) / 2;&#10;                segMin[idx] = Math.min(segMin[idx*2+1] + segAdd[idx*2+1], segMin[idx*2+2] + segAdd[idx*2+2]);&#10;            }&#10;            return;&#10;        }&#10;&#10;        int med = (fr + to) / 2;&#10;        add(l, r, x, idx*2+1, fr, med);&#10;        add(l, r, x, idx*2+2, med, to);&#10;    }&#10;&#10;    public long min(int l, int r) {&#10;        return min(l, r, 0, 0, M+1);&#10;    }&#10;&#10;    public long min(int l, int r, int idx, int fr, int to) {&#10;        if (to &lt;= l || r &lt;= fr) {&#10;            return Long.MAX_VALUE;&#10;        }&#10;        if (l &lt;= fr &amp;&amp; to &lt;= r) {&#10;            return segMin[idx] + segAdd[idx];&#10;        }&#10;&#10;        int med = (fr+to) / 2;&#10;        long ret = Long.MAX_VALUE;&#10;        ret = Math.min(ret, min(l, r, idx*2+1, fr, med));&#10;        ret = Math.min(ret, min(l, r, idx*2+2, med, to));&#10;        return ret + segAdd[idx];&#10;    }&#10;}" description="区間加算・区間最小値" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="ds.segment.rursq" value="import java.util.Arrays;&#10;&#10;/**&#10; * Segment tree (range update, range sum query).&#10; */&#10;public class SegmentTreeRURSQ {&#10;    int N;&#10;    int M;&#10;    long[] segSum;&#10;    long[] segUpd;&#10;&#10;    public SegmentTreeRURSQ(long[] data) {&#10;        N = Integer.highestOneBit(data.length-1)&lt;&lt;2;&#10;        M = (N &gt;&gt; 1) - 1;&#10;&#10;        segUpd = new long[N];&#10;        Arrays.fill(segUpd, -1);&#10;&#10;        segSum = new long[N];&#10;        for (int i = 0 ; i &lt; data.length ; i++) {&#10;            segSum[M+i] = data[i];&#10;        }&#10;        for (int i = M-1 ; i &gt;= 0 ; i--) {&#10;            segSum[i] = compute(i);&#10;        }&#10;    }&#10;&#10;    public long compute(int i) {&#10;        return segSum[i*2+1] +  segSum[i*2+2];&#10;    }&#10;&#10;    public void update(int l, int r, long k) {&#10;        update(l, r, k, 0, 0, M+1);&#10;    }&#10;&#10;    public void propagate(int idx, int fr, int to) {&#10;        if (segUpd[idx] != -1) {&#10;            int l = idx*2+1;&#10;            int r = idx*2+2;&#10;            if (r &lt; segUpd.length) {&#10;                segUpd[l] = segUpd[idx];&#10;                segUpd[r] = segUpd[idx];&#10;            }&#10;            segSum[idx] = (to-fr)*segUpd[idx];&#10;            segUpd[idx] = -1;&#10;        }&#10;    }&#10;&#10;    public void update(int l, int r, long x, int idx, int fr, int to) {&#10;        propagate(idx, fr, to);&#10;&#10;        if (to &lt;= l || r &lt;= fr) {&#10;            return;&#10;        }&#10;        if (l &lt;= fr &amp;&amp; to &lt;= r) {&#10;            segUpd[idx] = x;&#10;            propagate(idx, fr, to);&#10;            return;&#10;        }&#10;        int med = (fr + to) / 2;&#10;        update(l, r, x, idx*2+1, fr, med);&#10;        update(l, r, x, idx*2+2, med, to);&#10;&#10;        // make sure that child nodes have been propagated.&#10;        segSum[idx] = segSum[idx*2+1] + segSum[idx*2+2];&#10;    }&#10;&#10;    public long sum(int l, int r) {&#10;        return sum(l, r, 0, 0, M+1);&#10;    }&#10;&#10;    public long sum(int l, int r, int idx, int fr, int to) {&#10;        propagate(idx, fr, to);&#10;&#10;        if (to &lt;= l || r &lt;= fr) {&#10;            return 0;&#10;        }&#10;&#10;        if (l &lt;= fr &amp;&amp; to &lt;= r) {&#10;            return segSum[idx];&#10;        }&#10;        int med = (fr+to) / 2;&#10;        long ret = sum(l, r, idx*2+1, fr, med) + sum(l, r, idx*2+2, med, to);&#10;&#10;        // make sure that child nodes have been propagated.&#10;        segSum[idx] = segSum[idx*2+1] + segSum[idx*2+2];&#10;        return ret;&#10;    }&#10;}&#10;" description="区間更新・区間和" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="ds.unionfind" value="static class UnionFind {&#10;    int[] rank;&#10;    int[] parent;&#10;    int[] cnt;&#10;&#10;    public UnionFind(int n) {&#10;        rank = new int[n];&#10;        parent = new int[n];&#10;        cnt = new int[n];&#10;        for (int i = 0; i &lt; n ; i++) {&#10;            parent[i] = i;&#10;            cnt[i] = 1;&#10;        }&#10;    }&#10;&#10;    public int find(int a) {&#10;        if (parent[a] == a) {&#10;            return a;&#10;        }&#10;        parent[a] = find(parent[a]);&#10;        return parent[a];&#10;    }&#10;&#10;    public void unite(int a, int b) {&#10;        a = find(a);&#10;        b = find(b);&#10;        if (a == b) {&#10;            return;&#10;        }&#10;        if (rank[a] &lt; rank[b]) {&#10;            parent[a] = b;&#10;            cnt[b] += cnt[a];&#10;            cnt[a] = cnt[b];&#10;        } else {&#10;            parent[b] = a;&#10;            cnt[a] += cnt[b];&#10;            cnt[b] = cnt[a];&#10;            if (rank[a] == rank[b]) {&#10;                rank[a]++;&#10;            }&#10;        }&#10;    }&#10;&#10;    public int groupCount(int a) {&#10;        return cnt[find(a)];&#10;    }&#10;&#10;    private boolean issame(int a, int b) {&#10;        return find(a) == find(b);&#10;    }&#10;}&#10;" description="素集合データ構造" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="geometry.closestpoint" value="static long closestDistance(long[][] points) {&#10;    int n = points.length;&#10;    if (n &lt;= 1) {&#10;        return -1;&#10;    }&#10;    Arrays.sort(points, (a, b) -&gt; Long.signum(a[0] - b[0]));&#10;&#10;    TreeSet&lt;long[]&gt; set = new TreeSet&lt;&gt;((a, b) -&gt; {&#10;        if (a[0] == b[0]) {&#10;            return Long.signum(a[1] - b[1]);&#10;        }&#10;        return Long.signum(a[0] - b[0]);&#10;    });&#10;&#10;    long best = dist2(points[0], points[1]);&#10;    int idx = 0;&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        long sq = (long)Math.sqrt(best)+1;&#10;&#10;        while (points[idx][0] + sq &lt; points[i][0]) {&#10;            set.remove(new long[]{ points[i][1], idx});&#10;            idx++;&#10;        }&#10;&#10;        long[] fr = set.higher(new long[]{ points[i][1]-sq, -1 });&#10;        long[] to = set.higher(new long[]{ points[i][1]+sq, -1 });&#10;        Set&lt;long[]&gt; pset = null;&#10;        if (fr != null &amp;&amp; to != null) {&#10;            pset = set.subSet(fr, to);&#10;        } else if (fr != null) {&#10;            pset = set.tailSet(fr);&#10;        } else if (to != null) {&#10;            pset = set.headSet(to);&#10;        }&#10;        if (pset != null) {&#10;            for (long[] p : pset) {&#10;                int j = (int)p[1];&#10;                long d = dist2(points[i], points[j]);&#10;                if (best &gt; d) {&#10;                    best = d;&#10;                }&#10;            }&#10;        }&#10;        set.add(new long[]{ points[i][1], i });&#10;    }&#10;    return best;&#10;}&#10;&#10;private static long dist2(long[] a, long[] b) {&#10;    long dx = a[0]-b[0];&#10;    long dy = a[1]-b[1];&#10;    return dx*dx+dy*dy;&#10;}&#10;" description="最近対" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="geometry.convexhull" value="static class Point implements Comparable&lt;Point&gt; {&#10;    long x;&#10;    long y;&#10;&#10;    Point(long _x, long _y) {&#10;        x = _x;&#10;        y = _y;&#10;    }&#10;&#10;    Point(Point a, Point b) {&#10;        x = b.x - a.x;&#10;        y = b.y - a.y;&#10;    }&#10;&#10;    public int compareTo(Point o) {&#10;        if (x != o.x) {&#10;            return Long.signum(x - o.x);&#10;        }&#10;        return Long.signum(y - o.y);&#10;    }&#10;&#10;    public long det(Point other) {&#10;        return x * other.y - y * other.x;&#10;    }&#10;&#10;    public String toString() {&#10;        return &quot;(&quot; + x + &quot;,&quot; + y + &quot;)&quot;;&#10;    }&#10;}&#10;&#10;public static List&lt;Point&gt; convexHull(Point[] points) {&#10;    int n = points.length;&#10;    Arrays.sort(points);&#10;    Point[] candidate = new Point[n*2];&#10;    int k = 0;&#10;&#10;    // downer&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        while (k &gt; 1) {&#10;            Point a = new Point(candidate[k-2], candidate[k-1]);&#10;            Point b = new Point(candidate[k-1], points[i]);&#10;            if (a.det(b) &lt;= 0) {&#10;                k--;&#10;            } else {&#10;                break;&#10;            }&#10;        }&#10;        candidate[k++] = points[i];&#10;    }&#10;&#10;    // upper&#10;    int t = k;&#10;    for (int i = n-2 ; i &gt;= 0 ; i--) {&#10;        while (k &gt; t) {&#10;            Point a = new Point(candidate[k-2], candidate[k-1]);&#10;            Point b = new Point(candidate[k-1], points[i]);&#10;            if (a.det(b) &lt;= 0) {&#10;                k--;&#10;            } else {&#10;                break;&#10;            }&#10;        }&#10;        candidate[k++] = points[i];&#10;    }&#10;    List&lt;Point&gt; ret = new ArrayList&lt;Point&gt;();&#10;    for (int i = 0 ; i &lt; k - 1 ; i++) {&#10;        ret.add(candidate[i]);&#10;    }&#10;    return ret;&#10;}" description="凸包" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="geometry_2dpoint" value="static class Point implements Comparable&lt;Point&gt; {&#10;    long x;&#10;    long y;&#10;&#10;    public Point(long _x, long _y) {&#10;        x = _x;&#10;        y = _y;&#10;    }&#10;&#10;    long dot(Point o) {&#10;        return x * o.x + y * o.y;&#10;    }&#10;&#10;    long cross(Point o) {&#10;        return x * o.y - y * o.x;&#10;    }&#10;&#10;    Point to(Point o) {&#10;        return new Point(o.x - x, o.y - y);&#10;    }&#10;&#10;    static boolean innerTriangle(Point x1, Point x2, Point x3, Point y) {&#10;        Point v1 = x1.to(x2);&#10;        Point v2 = x2.to(x3);&#10;        Point v3 = x3.to(x1);&#10;        Point u1 = x1.to(y);&#10;        Point u2 = x2.to(y);&#10;        Point u3 = x3.to(y);&#10;        boolean c1 = v1.cross(u1) &gt; 0;&#10;        boolean c2 = v2.cross(u2) &gt; 0;&#10;        boolean c3 = v3.cross(u3) &gt; 0;&#10;        return c1 == c2 &amp;&amp; c2 == c3;&#10;    }&#10;&#10;    @Override&#10;    public int compareTo(Point o) {&#10;        return x == o.x ? Long.compare(y, o.y) : Long.compare(x, o.x);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return String.format(&quot;(%d,%d)&quot;, x, y);&#10;    }&#10;}" description="二次元幾何" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.dijkstra" value="static class Dijkstra {&#10;    int n;&#10;    int[][][] graph;&#10;&#10;    class State implements Comparable&lt;State&gt; {&#10;        int now;&#10;        long time;&#10;&#10;        State(int n, long t) {&#10;            now = n;&#10;            time = t;&#10;        }&#10;&#10;        @Override&#10;        public int compareTo(State o) {&#10;            return Long.compare(time, o.time);&#10;        }&#10;    }&#10;&#10;    public Dijkstra(int[][][] graph) {&#10;        this.n = graph.length;&#10;        this.graph = graph;&#10;    }&#10;&#10;    long[] doit(int from) {&#10;        long[] dp = new long[n];&#10;        Arrays.fill(dp, Long.MAX_VALUE / 10);&#10;        Queue&lt;State&gt; q = new PriorityQueue&lt;&gt;();&#10;        q.add(new State(from, 0));&#10;        dp[0] = 0;&#10;        while (q.size() &gt;= 1) {&#10;            State st = q.poll();&#10;            for (int[] e : graph[st.now]) {&#10;                long time = st.time + e[1];&#10;                if (dp[e[0]] &gt; time) {&#10;                    dp[e[0]] = time;&#10;                    q.add(new State(e[0], time));&#10;                }&#10;            }&#10;        }&#10;        return dp;&#10;    }&#10;}" description="Dijkstra" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.flow.matching" value="public static class Matching {&#10;    // Edmonds' cardinality matching algorithm. O(n^3)&#10;    int[][] graph;&#10;&#10;    int n;&#10;    int[] mu;&#10;    int[] phi;&#10;    int[] rho;&#10;    boolean[] scanned;&#10;&#10;    public Matching(int[][] graph) {&#10;        this.n = graph.length;&#10;        this.graph = graph;&#10;        mu = new int[n];&#10;        phi = new int[n];&#10;        rho = new int[n];&#10;        scanned = new boolean[n];&#10;        for (int i = 0; i &lt; n ; i++) {&#10;            mu[i] = phi[i] = rho[i] = i;&#10;        }&#10;    }&#10;&#10;    public int[] solve() {&#10;        int x = -1;&#10;        while (true) {&#10;            if (x == -1) {&#10;                for (int i = 0; i &lt; n; i++) {&#10;                    if (scanned[i]) {&#10;                        continue;&#10;                    }&#10;                    if (isEven(i)) {&#10;                        x = i;&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;            if (x == -1) {&#10;                break;&#10;            }&#10;            int y = -1;&#10;            for (int to : graph[x]) {&#10;                if (isOuter(to) || (isEven(to) &amp;&amp; rho[to] != rho[x])) {&#10;                    y = to;&#10;                }&#10;            }&#10;            if (y == -1) {&#10;                scanned[x] = true;&#10;                x = -1;&#10;            } else if (isOuter(y)) {&#10;                phi[y] = x;&#10;            } else {&#10;                int[] dx = new int[n];&#10;                int[] dy = new int[n];&#10;                Arrays.fill(dx, -1);&#10;                Arrays.fill(dy, -1);&#10;                for (int k = 0, w = x ; dx[w] &lt; 0 ; w = (k % 2 == 1 ? mu[w] : phi[w])) {&#10;                    dx[w] = k++;&#10;                }&#10;                for (int k = 0, w = y ; dy[w] &lt; 0 ; w = (k % 2 == 1 ? mu[w] : phi[w])) {&#10;                    dy[w] = k++;&#10;                }&#10;                boolean disjoint = true;&#10;                for (int i = 0; i &lt; n ; i++) {&#10;                    if (dx[i] &gt;= 0 &amp;&amp; dy[i] &gt; 0) {&#10;                        disjoint = false;&#10;                        break;&#10;                    }&#10;                }&#10;                if (disjoint) {&#10;                    for (int v = 0; v &lt; n ; v++) {&#10;                        if (dx[v] % 2 == 1) {&#10;                            mu[phi[v]] = v;&#10;                            mu[v] = phi[v];&#10;                        }&#10;                    }&#10;                    for (int v = 0; v &lt; n ; v++) {&#10;                        if (dy[v] % 2 == 1) {&#10;                            mu[phi[v]] = v;&#10;                            mu[v] = phi[v];&#10;                        }&#10;                    }&#10;                    mu[x] = y;&#10;                    mu[y] = x;&#10;                    for (int v = 0; v &lt; n ; v++) {&#10;                        phi[v] = rho[v] = v;&#10;                        scanned[v] = false;&#10;                    }&#10;                    x = -1;&#10;                } else {&#10;                    int r = x;&#10;                    int d = n;&#10;                    for (int v = 0; v &lt; n ; v++) {&#10;                        if (dx[v] &gt;= 0 &amp;&amp; dy[v] &gt;= 0 &amp;&amp; rho[v] == v &amp;&amp; d &gt; dx[v]) {&#10;                            d = dx[v];&#10;                            r = v;&#10;                        }&#10;                    }&#10;                    for (int v = 0; v &lt; n ; v++) {&#10;                        if (dx[v] &lt;= d &amp;&amp; dx[v] % 2 == 1 &amp;&amp; rho[phi[v]] != r) {&#10;                            phi[phi[v]] = v;&#10;                        }&#10;                    }&#10;                    for (int v = 0; v &lt; n ; v++) {&#10;                        if (dy[v] &lt;= d &amp;&amp; dy[v] % 2 == 1 &amp;&amp; rho[phi[v]] != r) {&#10;                            phi[phi[v]] = v;&#10;                        }&#10;                    }&#10;                    if (rho[x] != r) {&#10;                        phi[x] = y;&#10;                    }&#10;                    if (rho[y] != r) {&#10;                        phi[y] = x;&#10;                    }&#10;                    for (int v = 0; v &lt; n ; v++) {&#10;                        if (dx[rho[v]] &gt;= 0 || dy[rho[v]] &gt;= 0) {&#10;                            rho[v] = r;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return mu;&#10;    }&#10;&#10;    private boolean isEven(int idx) {&#10;        return mu[idx] == idx || (mu[idx] != idx &amp;&amp; phi[mu[idx]] != mu[idx]);&#10;    }&#10;&#10;    private boolean isOdd(int idx) {&#10;        return mu[idx] != idx &amp;&amp; phi[mu[idx]] == mu[idx] &amp;&amp; phi[idx] != idx;&#10;    }&#10;&#10;    private boolean isOuter(int idx) {&#10;        return mu[idx] != idx &amp;&amp; phi[mu[idx]] == mu[idx] &amp;&amp; phi[idx] == idx;&#10;    }&#10;}" description="一般マッチング" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.flow.maxflow_dinic" value="public static class MaxFlowDinic {&#10;    public List&lt;int[]&gt;[] graph;&#10;    public int[] deg;&#10;&#10;    public int[] level;&#10;    public int[] itr;&#10;&#10;    public int[] que;&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public void init(int size) {&#10;        graph = new List[size];&#10;        for (int i = 0; i &lt; size ; i++) {&#10;            graph[i] = new ArrayList&lt;int[]&gt;();&#10;        }&#10;        deg = new int[size];&#10;        level = new int[size];&#10;        itr = new int[size];&#10;        que = new int[size+10];&#10;    }&#10;    public void edge(int from, int to, int cap) {&#10;        int fdeg = deg[from];&#10;        int tdeg = deg[to];&#10;        graph[from].add(new int[]{to, cap, tdeg});&#10;        graph[to].add(new int[]{from, 0, fdeg});&#10;        deg[from]++;&#10;        deg[to]++;&#10;    }&#10;&#10;    public int dfs(int v, int t, int f) {&#10;        if (v == t) return f;&#10;        for (int i = itr[v] ; i &lt; graph[v].size() ; i++) {&#10;            itr[v] = i;&#10;            int[] e = graph[v].get(i);&#10;            if (e[1] &gt; 0 &amp;&amp; level[v] &lt; level[e[0]]) {&#10;                int d = dfs(e[0], t, Math.min(f, e[1]));&#10;                if (d &gt; 0) {&#10;                    e[1] -= d;&#10;                    graph[e[0]].get(e[2])[1] += d;&#10;                    return d;&#10;                }&#10;            }&#10;        }&#10;        return 0;&#10;    }&#10;&#10;    public void bfs(int s) {&#10;        Arrays.fill(level, -1);&#10;        int qh = 0;&#10;        int qt = 0;&#10;        level[s] = 0;&#10;        que[qh++] = s;&#10;        while (qt &lt; qh) {&#10;            int v = que[qt++];&#10;            for (int i = 0; i &lt; graph[v].size() ; i++) {&#10;                int[] e = graph[v].get(i);&#10;                if (e[1] &gt; 0 &amp;&amp; level[e[0]] &lt; 0) {&#10;                    level[e[0]] = level[v] + 1;&#10;                    que[qh++] = e[0];&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public int max_flow(int s, int t) {&#10;        int flow = 0;&#10;        while (true) {&#10;            bfs(s);&#10;            if (level[t] &lt; 0) {&#10;                return flow;&#10;            }&#10;            Arrays.fill(itr, 0);&#10;            while (true) {&#10;                int f = dfs(s, t, Integer.MAX_VALUE);&#10;                if (f &lt;= 0) {&#10;                    break;&#10;                }&#10;                flow += f;&#10;            }&#10;        }&#10;    }&#10;}" description="Dinicのアルゴリズムによる最大流" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.flow.maxflow_ford" value="public static class MaxFlowFord {&#10;    public class Edge {&#10;        int to;&#10;        int cap;&#10;        int rev;&#10;        public Edge(int _to, int _cap, int _rev) {&#10;            to = _to;&#10;            cap = _cap;&#10;            rev = _rev;&#10;        }&#10;    }&#10;&#10;    public List&lt;Edge&gt;[] graph;&#10;    public boolean[] used;&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public void init(int size) {&#10;        graph = new List[size];&#10;        for (int i = 0; i &lt; size ; i++) {&#10;            graph[i] = new ArrayList&lt;Edge&gt;();&#10;        }&#10;        used = new boolean[size];&#10;    }&#10;    public void edge(int from, int to, int cap) {&#10;        graph[from].add(new Edge(to, cap, graph[to].size()));&#10;        graph[to].add(new Edge(from, 0, graph[from].size() - 1));&#10;    }&#10;&#10;    public int dfs(int v, int t, int f) {&#10;        if (v == t) return f;&#10;        used[v] = true;&#10;        for (Edge e : graph[v]) {&#10;            if (!used[e.to] &amp;&amp; e.cap &gt; 0) {&#10;                int d = dfs(e.to, t, Math.min(f, e.cap));&#10;                if (d &gt; 0) {&#10;                    e.cap -= d;&#10;                    graph[e.to].get(e.rev).cap += d;&#10;                    return d;&#10;                }&#10;            }&#10;        }&#10;        return 0;&#10;    }&#10;    public int max_flow(int s, int t) {&#10;        int flow = 0;&#10;        while (true) {&#10;            used = new boolean[graph.length];&#10;            int f = dfs(s, t, Integer.MAX_VALUE);&#10;            if (f == 0) {&#10;                break;&#10;            }&#10;            flow += f;&#10;        }&#10;        return flow;&#10;    }&#10;}" description="Ford-Fulkersonアルゴリズムによる最大流" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.flow.mincostflow" value="public static class MinCostFlow {&#10;    public static class State implements Comparable&lt;State&gt; {&#10;        int dist;&#10;        int now;&#10;        public State(int _n, int _d) {&#10;            now = _n;&#10;            dist = _d;&#10;        }&#10;&#10;        @Override&#10;        public int compareTo(State o) {&#10;            return dist - o.dist;&#10;        }&#10;    }&#10;&#10;    public static class Edge {&#10;        int to;&#10;        int cap;&#10;        int rev;&#10;        int cost;&#10;        public Edge(int _to, int _cap, int _cost, int _rev) {&#10;            to = _to;&#10;            cap = _cap;&#10;            rev = _rev;&#10;            cost = _cost;&#10;        }&#10;    }&#10;&#10;    public static int INF = 1000000000;&#10;    public static int V;&#10;    public static int[] h;&#10;    public static int[] dist;&#10;    public static int[] prevv, preve;&#10;    public static List&lt;Edge&gt;[] graph;&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public static void init(int size) {&#10;        graph = new List[size];&#10;        for (int i = 0 ; i &lt; size ; i++) {&#10;            graph[i] = new ArrayList&lt;Edge&gt;();&#10;        }&#10;        dist = new int[size];&#10;        prevv = new int[size];&#10;        preve = new int[size];&#10;        h = new int[size];&#10;        V = size;&#10;    }&#10;&#10;    public static void edge(int from, int to, int cap, int cost) {&#10;        graph[from].add(new Edge(to, cap, cost, graph[to].size()));&#10;        graph[to].add(new Edge(from, 0, -cost, graph[from].size() - 1));&#10;    }&#10;&#10;    public static long min_cost_flow_be(int s, int t, int f) {&#10;        long res = 0;&#10;        Arrays.fill(h, 0);&#10;&#10;        // make sure that topo-sorted&#10;        for (int i = 0; i &lt; V ; i++) {&#10;            for (Edge e : graph[i]) {&#10;                if (e.cap &gt;= 1) {&#10;                    h[e.to] = Math.min(h[e.to], h[i] + e.cost);&#10;                }&#10;            }&#10;        }&#10;&#10;        Queue&lt;State&gt; q = new PriorityQueue&lt;State&gt;();&#10;        while (f &gt; 0) {&#10;            q.clear();&#10;            Arrays.fill(dist, INF);&#10;            dist[s] = 0;&#10;            q.add(new State(s, 0));&#10;            while (q.size() &gt;= 1) {&#10;                State stat = q.poll();&#10;                int v = stat.now;&#10;                if (dist[v] &lt; stat.dist) {&#10;                    continue;&#10;                }&#10;                for (int i = 0 ; i &lt; graph[v].size(); i++) {&#10;                    Edge e = graph[v].get(i);&#10;                    if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[v] + e.cost + h[v] - h[e.to]) {&#10;                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];&#10;                        prevv[e.to] = v;&#10;                        preve[e.to] = i;&#10;                        q.add(new State(e.to, dist[e.to]));&#10;                    }&#10;                }&#10;            }&#10;            if (dist[t] == INF) {&#10;                return res;&#10;            }&#10;            for (int v = 0 ; v &lt; V ; v++) {&#10;                h[v] += dist[v];&#10;            }&#10;            long d = f;&#10;            for (int v = t ; v != s ; v = prevv[v]) {&#10;                d = Math.min(d, graph[prevv[v]].get(preve[v]).cap);&#10;            }&#10;            f -= d;&#10;            res += d * h[t];&#10;            for (int v = t ; v != s ; v = prevv[v]) {&#10;                Edge e = graph[prevv[v]].get(preve[v]);&#10;                e.cap -= d;&#10;                Edge rev = graph[v].get(e.rev);&#10;                rev.cap += d;&#10;            }&#10;        }&#10;        return res;&#10;    }&#10;&#10;    public static long min_cost_flow(int s, int t, int f) {&#10;        long res = 0;&#10;        Arrays.fill(h, 0);&#10;        Queue&lt;State&gt; q = new PriorityQueue&lt;State&gt;();&#10;        while (f &gt; 0) {&#10;            q.clear();&#10;            Arrays.fill(dist, INF);&#10;            dist[s] = 0;&#10;            q.add(new State(s, 0));&#10;            while (q.size() &gt;= 1) {&#10;                State stat = q.poll();&#10;                int v = stat.now;&#10;                if (dist[v] &lt; stat.dist) {&#10;                    continue;&#10;                }&#10;                for (int i = 0 ; i &lt; graph[v].size(); i++) {&#10;                    Edge e = graph[v].get(i);&#10;                    if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[v] + e.cost + h[v] - h[e.to]) {&#10;                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];&#10;                        prevv[e.to] = v;&#10;                        preve[e.to] = i;&#10;                        q.add(new State(e.to, dist[e.to]));&#10;                    }&#10;                }&#10;            }&#10;            if (dist[t] == INF) {&#10;                return res;&#10;            }&#10;            for (int v = 0 ; v &lt; V ; v++) {&#10;                h[v] += dist[v];&#10;            }&#10;            long d = f;&#10;            for (int v = t ; v != s ; v = prevv[v]) {&#10;                d = Math.min(d, graph[prevv[v]].get(preve[v]).cap);&#10;            }&#10;            f -= d;&#10;            res += d * h[t];&#10;            for (int v = t ; v != s ; v = prevv[v]) {&#10;                Edge e = graph[prevv[v]].get(preve[v]);&#10;                e.cap -= d;&#10;                Edge rev = graph[v].get(e.rev);&#10;                rev.cap += d;&#10;            }&#10;        }&#10;        return res;&#10;    }&#10;}&#10;" description="最小費用流" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.lowlink" value="static class LowLink {&#10;    int n;&#10;    int[] parent;&#10;    int[] cnt;&#10;    int[] ord;&#10;    int[] low;&#10;    int[][] graph;&#10;    int[][] dfsTree;&#10;    boolean[] root;&#10;    int oi = 0;&#10;&#10;    public LowLink(int[][] graph) {&#10;        this.n = graph.length;&#10;        this.parent = new int[n];&#10;        this.graph = graph;&#10;        this.ord = new int[n];&#10;        this.low = new int[n];&#10;        this.root = new boolean[n];&#10;        this.cnt = new int[n];&#10;        this.dfsTree = new int[n][];&#10;        for (int i = 0; i &lt; n ; i++) {&#10;            this.dfsTree[i] = new int[graph[i].length];&#10;            Arrays.fill(this.dfsTree[i], -1);&#10;        }&#10;        Arrays.fill(parent, -1);&#10;        Arrays.fill(ord, -1);&#10;        Arrays.fill(low, n);&#10;    }&#10;&#10;    public void build() {&#10;        for (int i = 0 ; i &lt; n ; i++) {&#10;            if (ord[i] == -1) {&#10;                root[i] = true;&#10;                // optional&#10;                // dfsWithoutRecursive(i);&#10;                dfs(i, -1);&#10;                dfs0(i, -1);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void dfsWithoutRecursive(int rt) {&#10;        Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();&#10;        stk.push(rt);&#10;        stk.push(-1);&#10;        stk.push(-1);&#10;&#10;        List&lt;Integer&gt; vi = new ArrayList&lt;&gt;();&#10;        while (stk.size() &gt;= 1) {&#10;            int pid = stk.pop();&#10;            int par = stk.pop();&#10;            int now = stk.pop();&#10;            if (ord[now] != -1) {&#10;                continue;&#10;            }&#10;            vi.add(now);&#10;            if (pid &gt;= 0) {&#10;                dfsTree[par][pid] = now;&#10;            }&#10;            parent[now] = par;&#10;            ord[now] = oi;&#10;            low[now] = oi++;&#10;            for (int i = 0 ; i &lt; graph[now].length ; i++) {&#10;                int to = graph[now][i];&#10;                if (to == par) {&#10;                    continue;&#10;                }&#10;                if (ord[to] == -1) {&#10;                    stk.push(to);&#10;                    stk.push(now);&#10;                    stk.push(i);&#10;                }&#10;            }&#10;        }&#10;&#10;        for (int i = vi.size()-1 ; i &gt;= 0 ; i--) {&#10;            int now = vi.get(i);&#10;            cnt[now] = 1;&#10;            for (int j = 0 ; j &lt; graph[now].length ; j++) {&#10;                int to = graph[now][j];&#10;                if (to == parent[now]) {&#10;                    // ignore parent edge&#10;                    continue;&#10;                }&#10;                if (dfsTree[now][j] != -1) {&#10;                    cnt[now] += cnt[dfsTree[now][j]];&#10;                    low[now] = Math.min(low[now], low[dfsTree[now][j]]);&#10;                } else {&#10;                    // that's a back edge!&#10;                    low[now] = Math.min(low[now], ord[to]);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void dfs(int now, int par) {&#10;        if (ord[now] != -1) {&#10;            return;&#10;        }&#10;        ord[now] = oi;&#10;        low[now] = oi++;&#10;        for (int i = 0 ; i &lt; graph[now].length ; i++) {&#10;            int to = graph[now][i];&#10;            if (to == par) {&#10;                continue;&#10;            }&#10;            if (ord[to] == -1) {&#10;                dfsTree[now][i] = to;&#10;                dfs(to, now);&#10;                low[now] = Math.min(low[now], low[to]);&#10;            } else {&#10;                // that's a back edge!&#10;                low[now] = Math.min(low[now], ord[to]);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void dfs0(int now, int par) {&#10;        cnt[now] = 1;&#10;        for (int to : dfsTree[now]) {&#10;            if (to == -1 || to == par) {&#10;                continue;&#10;            }&#10;            dfs0(to, now);&#10;            cnt[now] += cnt[to];&#10;        }&#10;    }&#10;&#10;    private boolean isBridge(int u, int v) {&#10;        return ord[u] &lt; low[v];&#10;    }&#10;&#10;    private boolean isArticulationPoint(int u) {&#10;        if (root[u]) {&#10;            int cn = 0;&#10;            for (int to : dfsTree[u]) {&#10;                if (to != -1) {&#10;                    cn++;&#10;                }&#10;            }&#10;            return cn &gt;= 2;&#10;        } else {&#10;            for (int to : dfsTree[u]) {&#10;                if (to != -1 &amp;&amp; ord[u] &lt;= low[to]) {&#10;                    return true;&#10;                }&#10;            }&#10;            return false;&#10;        }&#10;    }&#10;}" description="橋とか関節点とかを求めるやつ" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.minimumspanningarborscence" value="public class MinimumSpanningArborescence {&#10;    int INF = 100000000;&#10;    int n;&#10;    int[][] graph;&#10;&#10;    /**&#10;     * @param adjacencyMatrix the graph represented&#10;     */&#10;    public MinimumSpanningArborescence(int[][] adjacencyMatrix) {&#10;        n = adjacencyMatrix.length;&#10;        graph = adjacencyMatrix;&#10;    }&#10;&#10;    public int doit(int root) {&#10;        int cost = 0;&#10;        int[] c = doit(graph, root);&#10;        int err = 0;&#10;        for (int j = 0; j &lt; n ; j++) {&#10;            if (c[j] &gt;= 0) {&#10;                cost += graph[c[j]][j];&#10;            } else {&#10;                err++;&#10;            }&#10;        }&#10;        return err &gt;= 2 ? -1 : cost;&#10;    }&#10;&#10;    private int[] doit(int[][] graph, int root) {&#10;        int n = graph.length;&#10;        int[] msa = new int[n];&#10;        Arrays.fill(msa, -1);&#10;&#10;        for (int i = 0; i &lt; n; i++) {&#10;            if (i == root) {&#10;                continue;&#10;            }&#10;            int min = INF;&#10;            int e = -1;&#10;            for (int j = 0; j &lt; n; j++) {&#10;                if (i == j) {&#10;                    continue;&#10;                }&#10;                if (min &gt; graph[j][i]) {&#10;                    min = graph[j][i];&#10;                    e = j;&#10;                }&#10;            }&#10;            msa[i] = e;&#10;        }&#10;&#10;        int[] res = detectCycle(msa);&#10;        if (res != null) {&#10;            int cv = res[0];&#10;&#10;            int[] map = new int[n];&#10;            Arrays.fill(map,-1);&#10;            int quo = n-res[1];&#10;            map[cv] = quo;&#10;&#10;            int mincy = graph[msa[cv]][cv];&#10;            for (int k=msa[cv]; k!=cv; k=msa[k]) {&#10;                map[k] = quo;&#10;                mincy = Math.min(mincy, graph[msa[k]][k]);&#10;            }&#10;&#10;            int[] imap = new int[n-res[1]];&#10;            int ptr = 0;&#10;            for (int i = 0; i &lt; n; i++) {&#10;                if (map[i] == quo) {&#10;                    continue;&#10;                }&#10;                map[i] = ptr;&#10;                imap[ptr] = i;&#10;                ptr++;&#10;            }&#10;&#10;            int[][] quog = new int[quo+1][quo+1];&#10;            for (int i = 0; i &lt; quo+1; i++) {&#10;                Arrays.fill(quog[i],INF);&#10;            }&#10;&#10;            int[] to = new int[n];&#10;            int[] from = new int[n];&#10;            for (int i = 0; i &lt; n; i++) {&#10;                if (map[i] != quo) {&#10;                    for (int j = 0; j &lt; n; j++) {&#10;                        if (map[j] == quo) {&#10;                            int nc = graph[i][j] - graph[msa[j]][j] + mincy;&#10;                            if (quog[map[i]][quo] &gt; nc) {&#10;                                quog[map[i]][quo] = nc;&#10;                                to[i] = j;&#10;                            }&#10;                        }else {&#10;                            quog[map[i]][map[j]] = graph[i][j];&#10;                        }&#10;                    }&#10;                } else {&#10;                    for (int j = 0; j &lt; n; j++) {&#10;                        if (map[j] != quo) {&#10;                            int nc = graph[i][j];&#10;                            if (quog[quo][map[j]] &gt; nc) {&#10;                                quog[quo][map[j]] = nc;&#10;                                from[j] = i;&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            int[] quomsa = doit(quog, map[root]);&#10;            for (int i = 0; i&lt;quo; i++) {&#10;                if (quomsa[i] == quo) {&#10;                    msa[imap[i]] = from[imap[i]];&#10;                } else if (quomsa[i] != -1) {&#10;                    msa[imap[i]] = imap[quomsa[i]];&#10;                }&#10;            }&#10;            int u = imap[quomsa[quo]];&#10;            msa[to[u]] = u;&#10;        }&#10;        return msa;&#10;    }&#10;&#10;    private int[] detectCycle(int[] f) {&#10;        int n = f.length;&#10;        BitSet visited = new BitSet(n);&#10;        outer:&#10;        for (int src = 0; src &lt; n; src++) {&#10;            if (visited.get(src) || f[src] &lt; 0) {&#10;                continue;&#10;            }&#10;            int power = 1;&#10;            int lambda = 1;&#10;            int tortoise = src;&#10;            int hare = f[src];&#10;            visited.set(src);&#10;            while (tortoise != hare) {&#10;                if (hare &lt; 0) {&#10;                    continue outer;&#10;                }&#10;                visited.set(hare);&#10;                if (power == lambda) {&#10;                    tortoise = hare;&#10;                    power &lt;&lt;= 1;&#10;                    lambda = 0;&#10;                }&#10;                hare = f[hare];&#10;                lambda++;&#10;            }&#10;            if (lambda &gt; 0) {&#10;                return new int[]{hare, lambda};&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;}" description="最小有向全域木" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.minimumsteinertree" value="public class MinimumSteinerTree {&#10;    private static final int INF = 100000000;&#10;&#10;    public static int minimumSteinerTree(int[][] graph, int[] terminals) {&#10;        int n = graph.length;&#10;        int[][] dist = new int[n][n];&#10;        for (int i = 0; i &lt; n ; i++) {&#10;            dist[i] = graph[i].clone();&#10;        }&#10;        for (int k = 0; k &lt; n ; k++) {&#10;            for (int i = 0; i &lt; n ; i++) {&#10;                for (int j = 0; j &lt; n ; j++) {&#10;                    dist[i][j] = Math.min(dist[i][j], dist[i][k]+dist[k][j]);&#10;                }&#10;            }&#10;        }&#10;&#10;        int tn = terminals.length;&#10;        int[][] opt = new int[1&lt;&lt;tn][n];&#10;        for (int i = 0; i &lt; opt.length ; i++) {&#10;            Arrays.fill(opt[i], INF);&#10;        }&#10;&#10;        for (int p = 0; p &lt; tn ; p++) {&#10;            for (int q = 0; q &lt; n ; q++) {&#10;                opt[1&lt;&lt;p][q] = dist[terminals[p]][q];&#10;            }&#10;        }&#10;        for (int s = 1; s &lt; 1&lt;&lt;tn ; s++) {&#10;            if ((s &amp; (s-1)) == 0) {&#10;                continue;&#10;            }&#10;            for (int p = 0 ; p &lt; n ; p++) {&#10;                for (int e = 0 ; e &lt; s ; e++) {&#10;                    if ((e | s) == s) {&#10;                        opt[s][p] = Math.min(opt[s][p], opt[e][p] + opt[s-e][p]);&#10;                    }&#10;                }&#10;            }&#10;            for (int p = 0 ; p &lt; n ; p++) {&#10;                for (int q = 0 ; q &lt; n ; q++) {&#10;                    opt[s][p] = Math.min(opt[s][p], opt[s][q] + dist[p][q]);&#10;                }&#10;            }&#10;        }&#10;&#10;        int ans = INF;&#10;        for (int s = 0 ; s &lt; (1&lt;&lt;tn) ; s++) {&#10;            for (int q = 0; q &lt; n ; q++) {&#10;                ans = Math.min(ans, opt[s][q] + opt[(1&lt;&lt;tn)-1-s][q]);&#10;            }&#10;        }&#10;        return ans;&#10;    }&#10;}&#10;" description="最小シュタイナー木" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.reverse_directedgraph" value="static int[][] reverseDirectedGraph(int[][] graph) {&#10;    int n = graph.length;&#10;    int[] deg = new int[n];&#10;&#10;    List&lt;int[]&gt; edges = new ArrayList&lt;&gt;();&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        for (int j : graph[i]) {&#10;            edges.add(new int[]{j, i});&#10;            deg[j]++;&#10;        }&#10;    }&#10;&#10;    int[][] ret = new int[n][];&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        ret[i] = new int[deg[i]];&#10;    }&#10;    for (int[] edge : edges) {&#10;        int a = edge[0];&#10;        int b = edge[1];&#10;        ret[a][--deg[a]] = b;&#10;    }&#10;    return ret;&#10;}&#10;&#10;" description="辺の向きを逆にしたグラフを作る" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.scc1" value="/**&#10; * Strongly connected component decomposition.&#10; */&#10;public class SCC1 {&#10;    boolean[] visited;&#10;    int[] node_id;&#10;    List&lt;Integer&gt; rev;&#10;&#10;    int n;&#10;    int[][] graph;&#10;    int[][] r_graph;&#10;&#10;    public SCC1(int[][] g) {&#10;        n = g.length;&#10;        graph = g;&#10;        r_graph = new int[n][];&#10;        int[] deg = new int[n];&#10;        for (int i = 0 ; i &lt; n ; i++) {&#10;            for (int j : graph[i]) {&#10;                deg[j]++;&#10;            }&#10;        }&#10;        for (int i = 0 ; i &lt; n ; i++) {&#10;            r_graph[i] = new int[deg[i]];&#10;        }&#10;        for (int i = 0 ; i &lt; n ; i++) {&#10;            for (int j : graph[i]) {&#10;                r_graph[j][--deg[j]] = i;&#10;            }&#10;        }&#10;    }&#10;&#10;    public int[] scc() {&#10;        visited = new boolean[n];&#10;        rev = new ArrayList&lt;Integer&gt;();&#10;        for (int i = 0; i&lt;n; i++) {&#10;            if (!visited[i]) {&#10;                dfs(i);&#10;            }&#10;        }&#10;        int id = 0;&#10;        node_id = new int[n];&#10;        visited = new boolean[n];&#10;        for (int i = rev.size()-1; i&gt;=0; i--) {&#10;            if (!visited[rev.get(i)]) {&#10;                rdfs(rev.get(i), id);&#10;                id++;&#10;            }&#10;        }&#10;        return node_id;&#10;    }&#10;&#10;    private void dfs(int i) {&#10;        visited[i] = true;&#10;        for (int next : graph[i]) {&#10;            if (!visited[next]) {&#10;                dfs(next);&#10;            }&#10;        }&#10;        rev.add(i);&#10;    }&#10;&#10;    private void rdfs(int i, int id) {&#10;        visited[i] = true;&#10;        node_id[i] = id;&#10;        for (int next : r_graph[i]) {&#10;            if (!visited[next]) {&#10;                rdfs(next, id);&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" description="Strongly Connected Component Decomposition" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.scc2" value="/**&#10; * Decompose graphs into component-bridge based tree.&#10; */&#10;public class SCC2 {&#10;    public static int[] decompose(int[][] graph) {&#10;        int n = graph.length;&#10;        boolean[] visited = new boolean[n];&#10;        int[] ord = new int[n];&#10;        int[] low = new int[n];&#10;&#10;        int[] ids = new int[n];&#10;        int[] inds = new int[n];&#10;        int[] parct = new int[n];&#10;        int pos = 0;&#10;        for (int i = 0 ; i &lt; n ; i++) {&#10;            if (visited[i]) {&#10;                continue;&#10;            }&#10;            ids[i] = i;&#10;            inds[0] = 0;&#10;            int sp = 1;&#10;            while (sp &gt; 0) {&#10;                int cur = ids[sp-1];&#10;                if (inds[sp-1] == 0) {&#10;                    visited[cur] = true;&#10;                    ord[cur] = low[cur] = pos++;&#10;                    parct[sp-1] = 0;&#10;                }&#10;                if (inds[sp-1] == graph[cur].length) {&#10;                    if(sp-2 &gt;= 0) {&#10;                        low[ids[sp-2]] = Math.min(low[ids[sp-2]], low[cur]);&#10;                    }&#10;                    sp--;&#10;                    continue;&#10;                }&#10;                int next = graph[cur][inds[sp-1]];&#10;                if (!visited[next]){&#10;                    ids[sp] = next;&#10;                    inds[sp] = 0;&#10;                    inds[sp-1]++;&#10;                    sp++;&#10;                    continue;&#10;                } else if (sp-2 &gt;= 0 &amp;&amp; (next != ids[sp-2] || ++parct[sp-1] &gt;= 2)){&#10;                    low[cur] = Math.min(low[cur], ord[next]);&#10;                }&#10;                inds[sp-1]++;&#10;            }&#10;        }&#10;&#10;        int[] clus = new int[n];&#10;        Arrays.fill(clus, -1);&#10;        int[] q = new int[n];&#10;        int cnum = 0;&#10;        for (int i = 0 ; i &lt; n ; i++){&#10;            if (clus[i] == -1){&#10;                int p = 0;&#10;                q[p++] = i;&#10;                clus[i] = cnum++;&#10;                for(int r = 0;r &lt; p;r++){&#10;                    int cur = q[r];&#10;                    for(int next : graph[cur]){&#10;                        if(clus[next] == -1){&#10;                            clus[next] = ord[cur] &lt; low[next] ? cnum++ : clus[cur];&#10;                            q[p++] = next;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return clus;&#10;    }&#10;&#10;    public static int[][] grouping(int[][] graph, int[] groups) {&#10;        int n = graph.length;&#10;        int gn = 0;&#10;&#10;        for (int g : groups) {&#10;            gn = Math.max(gn, g);&#10;        }&#10;&#10;        Set&lt;Long&gt; done = new HashSet&lt;&gt;();&#10;        List&lt;Integer&gt; edges = new ArrayList&lt;&gt;();&#10;        int[] deg = new int[gn+1];&#10;        for (int i = 0 ; i &lt; n ; i++) {&#10;            for (int j : graph[i]) {&#10;                if (groups[i] != groups[j] &amp;&amp; i &lt; j) {&#10;                    int gfr = Math.min(groups[i], groups[j]);&#10;                    int gto = Math.max(groups[i], groups[j]);&#10;                    long eid = (((long) gfr)&lt;&lt;30)+gto;&#10;                    if (done.contains(eid)) {&#10;                        continue;&#10;                    }&#10;                    done.add(eid);&#10;&#10;                    edges.add(gfr);&#10;                    edges.add(gto);&#10;                    deg[gfr]++;&#10;                    deg[gto]++;&#10;                }&#10;            }&#10;        }&#10;&#10;        int[][] groupedGraph = new int[gn+1][];&#10;        for (int i = 0 ; i &lt;= gn ; i++) {&#10;            groupedGraph[i] = new int[deg[i]];&#10;        }&#10;        int en = edges.size();&#10;        for (int i = 0 ; i &lt; en ; i += 2) {&#10;            int u = edges.get(i);&#10;            int v = edges.get(i+1);&#10;            groupedGraph[u][--deg[u]] = v;&#10;            groupedGraph[v][--deg[v]] = u;&#10;        }&#10;        return groupedGraph;&#10;    }&#10;}&#10;" description="Decompose graphs into component-bridge based tree." toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.scc3" value="/**&#10; * Decompose graph edges into components such that each component doesn't contain an articulation point.&#10; */&#10;public class SCC3 {&#10;    int n;&#10;    int[] ord;&#10;    int[] low;&#10;    int[][] graph;&#10;    boolean[] root;&#10;    int oi = 0;&#10;    Stack&lt;int[]&gt; tmpEdges;&#10;&#10;    List&lt;List&lt;int[]&gt;&gt; edgeComponents;&#10;&#10;    public SCC3(int[][] graph) {&#10;        this.n = graph.length;&#10;        this.graph = graph;&#10;        this.ord = new int[n];&#10;        this.low = new int[n];&#10;        this.root = new boolean[n];&#10;        tmpEdges = new Stack&lt;&gt;();&#10;        edgeComponents = new ArrayList&lt;&gt;();&#10;        Arrays.fill(ord, -1);&#10;        Arrays.fill(low, n);&#10;    }&#10;&#10;    public void build() {&#10;        for (int i = 0 ; i &lt; n ; i++) {&#10;            if (ord[i] == -1) {&#10;                root[i] = true;&#10;                dfs(i, -1);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void dfs(int now, int par) {&#10;        if (ord[now] != -1) {&#10;            return;&#10;        }&#10;        ord[now] = oi;&#10;        low[now] = oi++;&#10;        for (int i = 0 ; i &lt; graph[now].length ; i++) {&#10;            int to = graph[now][i];&#10;            if (to == par) {&#10;                continue;&#10;            }&#10;            if (ord[to] &lt; ord[now]) {&#10;                tmpEdges.add(new int[]{now, to});&#10;            }&#10;&#10;            if (ord[to] == -1) {&#10;                dfs(to, now);&#10;                low[now] = Math.min(low[now], low[to]);&#10;                if (low[to] &gt;= ord[now]) {&#10;                    List&lt;int[]&gt; edges = new ArrayList&lt;&gt;();&#10;                    while (tmpEdges.size() &gt;= 1) {&#10;                        int[] head = tmpEdges.pop();&#10;                        edges.add(head);&#10;                        if (Math.min(head[0], head[1]) == Math.min(now, to)) {&#10;                            if (Math.max(head[0], head[1]) == Math.max(now, to)) {&#10;                                break;&#10;                            }&#10;                        }&#10;                    }&#10;                    edgeComponents.add(edges);&#10;                }&#10;            } else {&#10;                // that's a back edge!&#10;                low[now] = Math.min(low[now], ord[to]);&#10;            }&#10;        }&#10;    }&#10;}&#10;" description="Decompose graph edges into components such that each component doesn't contain an articulation point." toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.topologicalsort1" value="static int[] toposort(int[][] graph) {&#10;    int n = graph.length;&#10;    int[] in = new int[n];&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        for (int t : graph[i]) {&#10;            in[t]++;&#10;        }&#10;    }&#10;&#10;    Queue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;();&#10;    int[] res = new int[n];&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        if (in[i] == 0) {&#10;            q.add(i);&#10;        }&#10;    }&#10;&#10;    int idx = 0;&#10;    while (q.size() &gt;= 1) {&#10;        int now = q.poll();&#10;        res[idx++] = now;&#10;        for (int t : graph[now]) {&#10;            in[t]--;&#10;            if (in[t] == 0) {&#10;                q.add(t);&#10;            }&#10;        }&#10;    }&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        if (in[i] &gt;= 1) {&#10;            return null;&#10;        }&#10;    }&#10;    return res;&#10;}&#10;" description="topological sort vertice of given graph" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.topologicalsort2" value="static int[] toposort(List&lt;Integer&gt;[] graph) {&#10;    int n = graph.length;&#10;    int[] in = new int[n];&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        for (int t : graph[i]) {&#10;            in[t]++;&#10;        }&#10;    }&#10;&#10;    Queue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;();&#10;    int[] res = new int[n];&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        if (in[i] == 0) {&#10;            q.add(i);&#10;        }&#10;    }&#10;&#10;    int idx = 0;&#10;    while (q.size() &gt;= 1) {&#10;        int now = q.poll();&#10;        res[idx++] = now;&#10;        for (int t : graph[now]) {&#10;            in[t]--;&#10;            if (in[t] == 0) {&#10;                q.add(t);&#10;            }&#10;        }&#10;    }&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        if (in[i] &gt;= 1) {&#10;            return null;&#10;        }&#10;    }&#10;    return res;&#10;}&#10;" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.tree.eulertour" value="static class EulerTour {&#10;    int n;&#10;    int[][] graph;&#10;    int[] parent;&#10;    int[] ar;&#10;    int[] cn;&#10;    int ai = 0;&#10;&#10;    public EulerTour(int[][] graph) {&#10;        this.graph = graph;&#10;        this.n = graph.length;&#10;        this.parent = new int[n];&#10;        this.ar = new int[2*n];&#10;        this.cn = new int[n];&#10;    }&#10;&#10;    private void go(int now) {&#10;        ar[ai++] = now;&#10;        int head = now;&#10;        while (head != -1) {&#10;            if (cn[head] != 0) {&#10;                break;&#10;            }&#10;            ar[ai++] = -(head+1);&#10;            head = parent[head];&#10;            if (head != -1) {&#10;                cn[head]--;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void parentChild(int root) {&#10;        int[] que = new int[4*n];&#10;        int qh = 0;&#10;        int qt = 0;&#10;        que[qh++] = root;&#10;        que[qh++] = -1;&#10;        while (qt &lt; qh) {&#10;            int now = que[qt++];&#10;            int par = que[qt++];&#10;            parent[now] = par;&#10;            for (int to : graph[now]) {&#10;                if (to != par) {&#10;                    que[qh++] = to;&#10;                    que[qh++] = now;&#10;                }&#10;            }&#10;        }&#10;        for (int i = 0; i &lt; n ; i++) {&#10;            cn[i] = (parent[i] == -1) ? graph[i].length : graph[i].length-1;&#10;        }&#10;    }&#10;&#10;    void build(int root) {&#10;        parentChild(root);&#10;&#10;        Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();&#10;        ai = 0;&#10;        stk.push(root);&#10;        stk.push(-1);&#10;        while (stk.size() &gt;= 1) {&#10;            int par = stk.pop();&#10;            int now = stk.pop();&#10;            go(now);&#10;            for (int to : graph[now]) {&#10;                if (to != par) {&#10;                    stk.push(to);&#10;                    stk.push(now);&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" description="非再帰版EulerTour" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.tree.heavylightdecomposition" value="public class HeavyLightDecomposition {&#10;    int n;&#10;    int[][] graph;&#10;    int root;&#10;&#10;    int[] parent;&#10;    int[] children;&#10;    int[] level;&#10;&#10;    int[] groupSize;&#10;    int[] groupID;&#10;    int[] groupLevel;&#10;&#10;    public HeavyLightDecomposition(int[][] g, int rt) {&#10;        n = g.length;&#10;        graph = g;&#10;        root = rt;&#10;        parent = new int[n];&#10;        children = new int[n];&#10;        level = new int[n];&#10;        prec();&#10;        doit();&#10;    }&#10;&#10;    public void prec() {&#10;        int qh = 0, qt = 0;&#10;        int[] que = new int[2*n];&#10;        que[qh++] = root;&#10;        que[qh++] = -1;&#10;&#10;        int[] ord = new int[n];&#10;        int oi = 0;&#10;        while (qt &lt; qh) {&#10;            int now = que[qt++];&#10;            int par = que[qt++];&#10;            parent[now] = par;&#10;            children[now]++;&#10;            if (par != -1) {&#10;                level[now] = level[par] + 1;&#10;            }&#10;            ord[oi++] = now;&#10;            for (int to : graph[now]) {&#10;                if (to != par) {&#10;                    que[qh++] = to;&#10;                    que[qh++] = now;&#10;                }&#10;            }&#10;        }&#10;        for (int i = n-1 ; i &gt;= 0 ; i--) {&#10;            int v = ord[i];&#10;            if (parent[v] != -1) {&#10;                children[parent[v]] += children[v];&#10;            }&#10;        }&#10;    }&#10;&#10;    public void doit() {&#10;        int[] next = new int[n];&#10;        int[] groupHeads = new int[n];&#10;        groupHeads[0] = root;&#10;&#10;        int gi = 1;&#10;        for (int i = 0 ; i &lt; n ; i++) {&#10;            int max = -1;&#10;            int maxJ = -1;&#10;            for (int j = 0 ; j &lt; graph[i].length ; j++) {&#10;                int to = graph[i][j];&#10;                if (parent[i] != to) {&#10;                    if (max &lt; children[to]) {&#10;                        max = children[to];&#10;                        maxJ = j;&#10;                    }&#10;                }&#10;            }&#10;            if (maxJ != -1) {&#10;                next[i] = graph[i][maxJ];&#10;                for (int j = 0; j &lt; graph[i].length; j++) {&#10;                    int to = graph[i][j];&#10;                    if (parent[i] != to &amp;&amp; j != maxJ) {&#10;                        groupHeads[gi++] = to;&#10;                    }&#10;                }&#10;            } else {&#10;                next[i] = -1;&#10;            }&#10;        }&#10;&#10;        groupID = new int[n];&#10;        groupLevel = new int[n];&#10;        groupSize = new int[gi];&#10;        for (int i = 0 ; i &lt; gi ; i++) {&#10;            int head = groupHeads[i];&#10;            groupID[head] = i;&#10;            while (next[head] != -1) {&#10;                int ne = next[head];&#10;                groupID[ne] = i;&#10;                groupLevel[ne] = groupLevel[head] + 1;&#10;                head = ne;&#10;            }&#10;        }&#10;        for (int i = 0; i &lt; n ; i++) {&#10;            groupSize[groupID[i]]++;&#10;        }&#10;    }&#10;}&#10;" description="木の重軽分解" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.tree.lca" value="/**&#10; * Lowest common anscestor.&#10; */&#10;public class LCA {&#10;    int[][] graph;&#10;    int[][] parent;&#10;    int[] depth;&#10;&#10;    public LCA(int[][] graph) {&#10;        int n = graph.length;&#10;        this.graph = graph;&#10;        init(n);&#10;    }&#10;&#10;    void dfs(int now, int from, int dep) {&#10;        parent[0][now] = from;&#10;        depth[now] = dep;&#10;        for (int to : graph[now]) {&#10;            if (to != from) {&#10;                dfs(to, now, dep+1);&#10;            }&#10;        }&#10;    }&#10;&#10;    void init(int n) {&#10;        int log = 1;&#10;        int nn = n;&#10;        while (nn &gt;= 1) {&#10;            nn /= 2;&#10;            log++;&#10;        }&#10;        parent = new int[log+1][n];&#10;        for (int i = 0 ; i &lt;= log ; i++) {&#10;            Arrays.fill(parent[i], -1);&#10;        }&#10;        depth = new int[n];&#10;&#10;        dfs(0, -1, 0);&#10;&#10;        for (int k = 0 ; k &lt; log ; k++) {&#10;            for (int v = 0 ; v &lt; n ; v++) {&#10;                if (parent[k][v] &lt; 0) {&#10;                    parent[k+1][v] = -1;&#10;                } else {&#10;                    parent[k+1][v] = parent[k][parent[k][v]];&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    int lca(int u, int v) {&#10;        int loglen = parent.length;&#10;        if (depth[u] &gt; depth[v]) {&#10;            int tmp = u;&#10;            u = v;&#10;            v = tmp;&#10;        }&#10;        for (int k = 0 ; k &lt; loglen ; k++) {&#10;            if (((depth[v] - depth[u]) &gt;&gt; k) % 2 == 1) {&#10;                v = parent[k][v];&#10;            }&#10;        }&#10;        if (u == v) {&#10;            return u;&#10;        }&#10;&#10;        for (int k = loglen-1 ; k &gt;= 0 ; k--) {&#10;            if (parent[k][u] != parent[k][v]) {&#10;                u = parent[k][u];&#10;                v = parent[k][v];&#10;            }&#10;        }&#10;        return parent[0][u];&#10;    }&#10;&#10;    int dist(int x, int y) {&#10;        int l = lca(x, y);&#10;        return depth[x] + depth[y] - depth[l] * 2;&#10;    }&#10;}" description="LCA" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.tree.parentcountorder" value="/**&#10; * Computes each node's {parent, number of vertices in its subtrees, BFS order} with given tree.&#10; * It returns array of size 3*n.&#10; *&#10; * O(n)&#10; *&#10; * @param graph&#10; * @param root&#10; * @return&#10; */&#10;public static int[][] parentCountOrder(int[][] graph, int root) {&#10;    int n = graph.length;&#10;    int[] que = new int[2*n];&#10;    int[] parent = new int[n];&#10;    int[] bfsOrd = new int[n];&#10;    int[] cnt = new int[n];&#10;    int qh = 0, qt = 0;&#10;    que[qh++] = root;&#10;    que[qh++] = -1;&#10;    int vi = 0;&#10;    while (qt &lt; qh) {&#10;        int now = que[qt++];&#10;        int par = que[qt++];&#10;        parent[now] = par;&#10;        bfsOrd[vi++] = now;&#10;        for (int to : graph[now]) {&#10;            if (to == par) {&#10;                continue;&#10;            }&#10;            que[qh++] = to;&#10;            que[qh++] = now;&#10;        }&#10;    }&#10;    for (int i = n-1 ; i &gt;= 0 ; i--) {&#10;        int now = bfsOrd[i];&#10;        cnt[now]++;&#10;        if (parent[now] != -1) {&#10;            cnt[parent[now]] += cnt[now];&#10;        }&#10;    }&#10;    return new int[][]{ parent, cnt, bfsOrd };&#10;}&#10;" description="根付き木の親、部分木のサイズ、行きがけ順を計算" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="graph.tree.tree_lca_query" value="static class TreeLCAQuery {&#10;    LCA lca;&#10;    int[] val;&#10;    int[][] dbl;&#10;&#10;    public TreeLCAQuery(LCA lca, int[] val) {&#10;        int n = val.length;&#10;        this.lca = lca;&#10;        this.val = val;&#10;        int lg = lca.parent.length;&#10;        dbl = new int[lg][n];&#10;        for (int i = 0 ; i &lt; n ; i++) {&#10;            dbl[0][i] = val[i];&#10;        }&#10;        for (int l = 1 ; l &lt; lg ; l++) {&#10;            for (int i = 0 ; i &lt; n ; i++) {&#10;                int half = lca.parent[l-1][i];&#10;                if (half &gt;= 0) {&#10;                    dbl[l][i] = Math.min(dbl[l-1][i], dbl[l-1][half]);&#10;                } else {&#10;                    dbl[l][i] = dbl[l-1][i];&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public int min(int u, int v) {&#10;        int min = Integer.MAX_VALUE;&#10;        while (u != v) {&#10;            int diff = lca.depth[u] - lca.depth[v];&#10;            int ctr = -1;&#10;            while (diff &gt; 0) {&#10;                ctr++;&#10;                diff /= 2;&#10;            }&#10;            min = Math.min(min, dbl[ctr][u]);&#10;            u = lca.parent[ctr][u];&#10;        }&#10;        min = Math.min(min, dbl[0][u]);&#10;        return min;&#10;    }&#10;}&#10;" description="ツリー上のクエリをLCAで解く" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="numeric.gcd" value="public static long gcd(long a, long b) {&#10;    return b == 0 ? a : gcd(b, a%b);&#10;}&#10;" description="gcd" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="numeric.prime" value="/**&#10; * Computes Euler's totient function value of num : φ(num)&#10; *&#10; * O(sqrt(n))&#10; *&#10; * @param num&#10; * @return&#10; */&#10;static long totient(long num) {&#10;    int[] primes = generatePrimes((int)Math.sqrt(num)+10);&#10;&#10;    long ans = 1;&#10;    for (long p : primes) {&#10;        if (num &lt; p) {&#10;            break;&#10;        }&#10;        long pn = 1;&#10;        while (num % p == 0) {&#10;            pn *= p;&#10;            num /= p;&#10;        }&#10;        ans *= (pn / p) * (p - 1);&#10;    }&#10;    if (num &gt;= 2) {&#10;        ans *= num - 1;&#10;    }&#10;    return ans;&#10;}&#10;&#10;&#10;/**&#10; * Generates primes less than upto.&#10; *&#10; * O(nlog(logn))&#10; *&#10; * @param upto limit&#10; * @return array of primes&#10; */&#10;static int[] generatePrimes(int upto) {&#10;    boolean[] isp = new boolean[upto];&#10;    Arrays.fill(isp, true);&#10;    isp[0] = isp[1] = false;&#10;&#10;    int pi = 0;&#10;    for (int i = 2; i &lt; upto ; i++) {&#10;        if (isp[i]) {&#10;            pi++;&#10;            for (int j = i * 2; j &lt; upto; j += i) {&#10;                isp[j] = false;&#10;            }&#10;        }&#10;    }&#10;&#10;    int[] ret = new int[pi];&#10;    int ri = 0;&#10;    for (int i = 2 ; i &lt; upto ; i++) {&#10;        if (isp[i]) {&#10;            ret[ri++] = i;&#10;        }&#10;    }&#10;    return ret;&#10;}&#10;&#10;/**&#10; * Moebius function. Returns array of μ(n).&#10; * O(n)&#10; *&#10; * @param n limit&#10; * @return array of μ(n)&#10; */&#10;public static int[] moebius(int n) {&#10;    boolean[] isp = new boolean[n];&#10;    Arrays.fill(isp, true);&#10;    isp[1] = isp[0] = false;&#10;    for (int i = 2 ; i &lt; isp.length ; i++) {&#10;        if (isp[i]) {&#10;            for (int ii = i*2 ; ii &lt; isp.length ; ii += i) {&#10;                isp[ii] = false;&#10;            }&#10;        }&#10;    }&#10;&#10;    int[] mb = new int[n];&#10;    Arrays.fill(mb, 1);&#10;    for (int x = 1 ; x &lt; mb.length ; x++) {&#10;        if (isp[x]) {&#10;            int cnt = 1;&#10;            for (int xx = x ; xx &lt; mb.length ; xx += x) {&#10;                if (cnt % x == 0) {&#10;                    mb[xx] = 0;&#10;                } else {&#10;                    mb[xx] *= -1;&#10;                }&#10;                cnt++;&#10;            }&#10;        }&#10;    }&#10;    return mb;&#10;}" description="totient,素数,moebius" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="string.suffix_array" value="static class SuffixArray {&#10;    int n;&#10;    char[] base;&#10;&#10;    Integer[] sa;&#10;    int[] rank;&#10;    int[] tmp;&#10;    int[] lcp;&#10;&#10;    int compareNode(int i, int j, int k) {&#10;        if (rank[i] != rank[j]) {&#10;            return rank[i] - rank[j];&#10;        } else {&#10;            int ri = i + k &lt;= n ? rank[i+k] : -1;&#10;            int rj = j + k &lt;= n ? rank[j+k] : -1;&#10;            return ri - rj;&#10;        }&#10;    }&#10;&#10;    public SuffixArray(char[] x) {&#10;        base = x;&#10;        n = base.length;&#10;    }&#10;&#10;    void buildSA() {&#10;        sa = new Integer[n+1];&#10;        rank = new int[n+1];&#10;        tmp = new int[n+1];&#10;        for (int i = 0 ; i &lt;= n ; i++) {&#10;            sa[i] = i;&#10;            rank[i] = (i &lt; n) ? base[i] : -1;&#10;        }&#10;        for (int _k = 1 ; _k &lt;= n ; _k *= 2) {&#10;            final int k = _k;&#10;            Arrays.sort(sa, new Comparator&lt;Integer&gt;() {&#10;                @Override&#10;                public int compare(Integer i, Integer j) {&#10;                    return compareNode(i, j, k);&#10;                }&#10;            });&#10;            tmp[sa[0]] = 0;&#10;            for (int i = 1 ; i &lt;= n ; i++) {&#10;                tmp[sa[i]] = tmp[sa[i-1]] + ((compareNode(sa[i-1], sa[i], k) &lt; 0) ? 1 : 0);&#10;            }&#10;            for (int i = 0 ; i &lt;= n ; i++) {&#10;                rank[i] = tmp[i];&#10;            }&#10;        }&#10;    }&#10;&#10;    void buildLCP() {&#10;        for (int i = 0 ; i &lt;= n ; i++) {&#10;            rank[sa[i]] = i;&#10;        }&#10;        lcp = new int[n];&#10;        int h = 0;&#10;        for (int i = 0 ; i &lt; n ; i++) {&#10;            int j = sa[rank[i]-1];&#10;            if (h &gt; 0) {&#10;                h--;&#10;            }&#10;            for (; j + h &lt; n &amp;&amp; i + h &lt; n ; h++) {&#10;                if (base[j+h] != base[i+h]) {&#10;                    break;&#10;                }&#10;            }&#10;            lcp[rank[i]-1] = h;&#10;        }&#10;    }&#10;}" description="文字列の接尾辞配列" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="string.trie" value="public class PrefixAutomaton {&#10;    int n;&#10;    char[][] words;&#10;    int[][] next;&#10;    int[] parentId;&#10;    int[] lastCharacter;&#10;    int[] failure;&#10;    int[] cnt;&#10;    int[] hereCnt;&#10;    int[] cmp;&#10;    int ni;&#10;&#10;    public PrefixAutomaton(char[][] words) {&#10;        n = 1;&#10;        this.words = words;&#10;        for (int i = 0; i &lt; words.length ; i++) {&#10;            n += words[i].length;&#10;        }&#10;        next = new int[n+1][26];&#10;        parentId = new int[n+1];&#10;        lastCharacter = new int[n+1];&#10;        cnt = new int[n+1];&#10;        hereCnt = new int[n+1];&#10;        cmp = new int[n+1];&#10;        ni = 1;&#10;        for (char[] w : words) {&#10;            add(w);&#10;        }&#10;        buildFailureLink();&#10;        goup();&#10;    }&#10;&#10;    public int go(char[] l) {&#10;        int head = 0;&#10;        for (int i = 0; i &lt; l.length ; i++) {&#10;            head = next[head][l[i]-'a'];&#10;        }&#10;        return head;&#10;    }&#10;&#10;    private void add(char[] c) {&#10;        int head = 0;&#10;        for (int i = 0; i &lt; c.length ; i++) {&#10;            int ci = c[i]-'a';&#10;            if (next[head][ci] == 0) {&#10;                next[head][ci] = ni++;&#10;            }&#10;            parentId[next[head][ci]] = head;&#10;            head = next[head][ci];&#10;            lastCharacter[head] = ci;&#10;        }&#10;    }&#10;&#10;    private void buildFailureLink() {&#10;        int[] que = new int[n];&#10;        int qh = 0;&#10;        int qt = 0;&#10;        que[qh++] = 0;&#10;        failure = new int[n];&#10;        while (qt &lt; qh) {&#10;            int now = que[qt++];&#10;            if (parentId[now] &gt;= 1) {&#10;                int parFail = failure[parentId[now]];&#10;                failure[now] = next[parFail][lastCharacter[now]];&#10;            }&#10;            for (int j = 0; j &lt; 26 ; j++) {&#10;                if (next[now][j] == 0) {&#10;                    next[now][j] = next[failure[now]][j];&#10;                } else {&#10;                    que[qh++] = next[now][j];&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void goup() {&#10;        for (int i = ni-1 ; i &gt;= 1 ; i--) {&#10;            cnt[parentId[i]] += cnt[i];&#10;        }&#10;    }&#10;&#10;    public void compress() {&#10;        for (int i = 1 ; i &lt; ni ; i++) {&#10;            int has = 0;&#10;            int onlyID = -1;&#10;            for (int k = 0 ; k &lt; 26 ; k++) {&#10;                if (next[i][k] != 0) {&#10;                    onlyID = next[i][k];&#10;                    has++;&#10;                }&#10;            }&#10;            if (has == 1 &amp;&amp; hereCnt[i] == 0) {&#10;                int my = lastCharacter[i];&#10;                next[parentId[i]][my] = onlyID;&#10;                parentId[onlyID] = parentId[i];&#10;                lastCharacter[onlyID] = my;&#10;            }&#10;        }&#10;    }&#10;}" description="Trie(Prefix automaton)" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="string.zfunction" value="/**&#10; * Computes z-function of given string a.&#10; * (z[idx] := longest common prefix of ([idx,n), [0,n))&#10; *&#10; * @param a&#10; * @return&#10; */&#10;public static int[] buildZ(char[] a) {&#10;    int n = a.length;&#10;    int[] z = new int[n];&#10;    if (n == 0) return z;&#10;    z[0] = n;&#10;    int l = 0, r = 0;&#10;    for (int i = 1; i &lt; n; i++) {&#10;        if (i &gt; r) {&#10;            l = r = i;&#10;            while (r &lt; n &amp;&amp; a[r - l] == a[r]) {&#10;                r++;&#10;            }&#10;            z[i] = r - l;&#10;            r--;&#10;        } else {&#10;            int k = i - l;&#10;            if (z[k] &lt; r - i + 1) {&#10;                z[i] = z[k];&#10;            } else {&#10;                l = i;&#10;                while (r &lt; n &amp;&amp; a[r - l] == a[r]) {&#10;                    r++;&#10;                }&#10;                z[i] = r - l;&#10;                r--;&#10;            }&#10;        }&#10;    }&#10;    return z;&#10;}" description="Z関数" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="tmpl" value="import java.io.IOException;&#10;import java.io.InputStream;&#10;import java.io.PrintWriter;&#10;import java.util.Arrays;&#10;import java.util.InputMismatchException;&#10;&#10;public class XXXXXX {&#10;    public static void main(String[] args) {&#10;        InputReader in = new InputReader(System.in);&#10;        PrintWriter out = new PrintWriter(System.out);&#10;&#10;        int x = in.nextInt();&#10;        out.println(x);&#10;&#10;        out.flush();&#10;    }&#10;&#10;    static class InputReader {&#10;        private InputStream stream;&#10;        private byte[] buf = new byte[1024];&#10;        private int curChar;&#10;        private int numChars;&#10;&#10;        public InputReader(InputStream stream) {&#10;            this.stream = stream;&#10;        }&#10;&#10;        private int next() {&#10;            if (numChars == -1)&#10;                throw new InputMismatchException();&#10;            if (curChar &gt;= numChars) {&#10;                curChar = 0;&#10;                try {&#10;                    numChars = stream.read(buf);&#10;                } catch (IOException e) {&#10;                    throw new InputMismatchException();&#10;                }&#10;                if (numChars &lt;= 0)&#10;                    return -1;&#10;            }&#10;            return buf[curChar++];&#10;        }&#10;&#10;        public int nextInt() {&#10;            int c = next();&#10;            while (isSpaceChar(c))&#10;                c = next();&#10;            int sgn = 1;&#10;            if (c == '-') {&#10;                sgn = -1;&#10;                c = next();&#10;            }&#10;            int res = 0;&#10;            do {&#10;                if (c &lt; '0' || c &gt; '9')&#10;                    throw new InputMismatchException();&#10;                res *= 10;&#10;                res += c - '0';&#10;                c = next();&#10;            } while (!isSpaceChar(c));&#10;            return res * sgn;&#10;        }&#10;&#10;        public long nextLong() {&#10;            int c = next();&#10;            while (isSpaceChar(c))&#10;                c = next();&#10;            long sgn = 1;&#10;            if (c == '-') {&#10;                sgn = -1;&#10;                c = next();&#10;            }&#10;            long res = 0;&#10;            do {&#10;                if (c &lt; '0' || c &gt; '9')&#10;                    throw new InputMismatchException();&#10;                res *= 10;&#10;                res += c - '0';&#10;                c = next();&#10;            } while (!isSpaceChar(c));&#10;            return res * sgn;&#10;        }&#10;&#10;        public boolean isSpaceChar(int c) {&#10;            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;&#10;        }&#10;&#10;        public interface SpaceCharFilter {&#10;            public boolean isSpaceChar(int ch);&#10;        }&#10;    }&#10;&#10;    static void debug(Object... o) {&#10;        System.err.println(Arrays.deepToString(o));&#10;    }&#10;}&#10;" description="solution template" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="utils.convexhulltech" value="/**&#10; * Convex hull technique.&#10; * Given many lines(say y = a_{i} * x + b_{i}), computes many query:&#10; *   what is the maximum y of current lines with given x?&#10; *&#10; * O(n+qlogn) where q = (number of queries), n = (maximum number of lines).&#10; */&#10;public class ConvexHullTech {&#10;    long[][] stk;&#10;    int tail = 0;&#10;&#10;    public ConvexHullTech(int maxLines) {&#10;        stk = new long[maxLines][2];&#10;    }&#10;&#10;    // add line : ax + b&#10;    public void addLine(long a, long b) {&#10;        stk[tail][0] = a;&#10;        stk[tail][1] = b;&#10;        tail++;&#10;        while (tail &gt;= 3 &amp;&amp; compare(stk[tail-3], stk[tail-2], stk[tail-1])) {&#10;            stk[tail-2][0] = stk[tail-1][0];&#10;            stk[tail-2][1] = stk[tail-1][1];&#10;            tail--;&#10;        }&#10;    }&#10;&#10;    private boolean compare(long[] l1, long[] l2, long[] l3) {&#10;        long a1 = l1[0];&#10;        long a2 = l2[0];&#10;        long a3 = l3[0];&#10;        long b1 = l1[1];&#10;        long b2 = l2[1];&#10;        long b3 = l3[1];&#10;        return  (a2 - a1) * (b3 - b2) &gt;= (a3 - a2) * (b2 - b1);&#10;    }&#10;&#10;    long val(int lidx, long x) {&#10;        return stk[lidx][0] * x + stk[lidx][1];&#10;    }&#10;&#10;    public long[] queryMax(long x) {&#10;        int min = -1;&#10;        int max = tail - 1;&#10;        while (max - min &gt; 1) {&#10;            int med = (max + min) / 2;&#10;            if (val(med, x) &lt;= val(med+1, x)) {&#10;                min = med;&#10;            } else {&#10;                max = med;&#10;            }&#10;        }&#10;        return stk[max];&#10;    }&#10;&#10;    public long computesMax(long x) {&#10;        long[] line = queryMax(x);&#10;        return line[0] * x + line[1];&#10;    }&#10;&#10;    public long[] queryMin(long x) {&#10;        int min = -1;&#10;        int max = tail - 1;&#10;        while (max - min &gt; 1) {&#10;            int med = (max + min) / 2;&#10;            if (val(med, x) &gt;= val(med+1, x)) {&#10;                min = med;&#10;            } else {&#10;                max = med;&#10;            }&#10;        }&#10;        return stk[max];&#10;    }&#10;&#10;    public long computesMin(long x) {&#10;        long[] line = queryMin(x);&#10;        return line[0] * x + line[1];&#10;    }&#10;}&#10;" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="utils.countrangecoveringrange" value="/**&#10; * Counts how many ranges in [l,r).&#10; * Answers multiple query.&#10; *&#10; * O((n+q)logn) where q = query.length, n = ranges.length&#10; *&#10; * @param ranges array of [l,r)&#10; * @param query answerCountQuery query&#10; * @return answers to the queries&#10; */&#10;public static int[] answerCountQuery(int[][] ranges, int[][] query) {&#10;    int n = ranges.length;&#10;    int q = query.length;&#10;    int[][] qinfo = new int[q][3];&#10;    for (int i = 0; i &lt; q ; i++) {&#10;        qinfo[i] = new int[]{ query[i][0], query[i][1], i };&#10;    }&#10;    Arrays.sort(qinfo, (q0, q1) -&gt; q0[0] - q1[0]);&#10;    Arrays.sort(ranges, (r0, r1) -&gt; r0[0] - r1[0]);&#10;&#10;    // it may need value compression.&#10;    FenwickTree bit = new FenwickTree(1000010);&#10;    for (int i = 0; i &lt; n ; i++) {&#10;        bit.add(ranges[i][1], 1);&#10;    }&#10;&#10;    int[] ans = new int[q];&#10;    int head = 0;&#10;    for (int i = 0; i &lt; q ; i++) {&#10;        while (head &lt; n &amp;&amp; ranges[head][0] &lt; qinfo[i][0]) {&#10;            bit.add(ranges[head][1], -1);&#10;            head++;&#10;        }&#10;        ans[qinfo[i][2]] = (int)bit.range(qinfo[i][0]+1, qinfo[i][1]);&#10;    }&#10;    return ans;&#10;}&#10;" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="utils.d4" value="private int[] dx = new int[]{0, -1, 0, 1};&#10;private int[] dy = new int[]{-1, 0, 1, 0};&#10;" description="direction four" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="utils.dbg" value="public static void debug(Object... o) {&#10;    System.err.println(Arrays.deepToString(o));&#10;}&#10;" description="debug" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="utils.dice" value="class Dice {&#10;    final static int MAXCODE = 777;&#10;&#10;    static enum Direction {&#10;        LEFT(-1, 0),&#10;        RIGHT(1, 0),&#10;        UP(0, -1),&#10;        DOWN(0, 1);&#10;&#10;        int dx;&#10;        int dy;&#10;&#10;        Direction(int dx, int dy) {&#10;            this.dx = dx;&#10;            this.dy = dy;&#10;        }&#10;    }&#10;&#10;    static int[][][][][] diceMap = new int[7][7][7][4][3];&#10;&#10;    static void buildDiceMap() {&#10;        for (int i = 1 ; i &lt;= 6 ; i++) {&#10;            for (int j = 1 ; j &lt;= 6 ; j++) {&#10;                for (int k = 1 ; k &lt;= 6 ; k++) {&#10;                    if (i == j || j == k || i == k) {&#10;                        continue;&#10;                    }&#10;                    Dice dice = new Dice(i, j, k);&#10;                    Dice[] dices = new Dice[]{dice.right(), dice.up(), dice.down(), dice.left()};&#10;                    for (int d = 0 ; d &lt; 4 ; d++) {&#10;                        Dice di = dices[d];&#10;                        diceMap[i][j][k][d] = new int[]{di.top, di.up, di.right};&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    int top;&#10;    int up;&#10;    int right;&#10;&#10;    public Dice(int t, int u, int r) {&#10;        top = t;&#10;        up = u;&#10;        right = r;&#10;    }&#10;&#10;    public String toString() {&#10;        return String.format(&quot;%d/%d/%d&quot;, top, up, right);&#10;    }&#10;&#10;    public Dice move(Direction dir) {&#10;        switch (dir) {&#10;            case LEFT:&#10;                return left();&#10;            case RIGHT:&#10;                return right();&#10;            case UP:&#10;                return up();&#10;            case DOWN:&#10;                return down();&#10;        }&#10;        throw new RuntimeException(&quot;invalid direction : &quot; + dir);&#10;    }&#10;&#10;    private Dice left() {&#10;        return new Dice(right, up, 7-top);&#10;    }&#10;&#10;    private Dice right() {&#10;        return new Dice(7-right, up, top);&#10;    }&#10;&#10;    private Dice up() {&#10;        return new Dice(7-up, top, right);&#10;    }&#10;&#10;    private Dice down() {&#10;        return new Dice(up, 7-top, right);&#10;    }&#10;&#10;    public int encode() {&#10;        return (top&lt;&lt;6)+(up&lt;&lt;3)+right;&#10;    }&#10;&#10;    public static Dice decode(int code) {&#10;        int top = (code&gt;&gt;6)&amp;7;&#10;        int up = (code&gt;&gt;3)&amp;7;&#10;        int right = code&amp;7;&#10;        return new Dice(top, up, right);&#10;    }&#10;&#10;    public static Dice initialDice() {&#10;        return new Dice(1, 2, 3);&#10;    }&#10;}" description="サイコロ" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="utils.distinctnumberrange1" value="/**&#10; * Computes distinct numbers of give array.&#10; * Answers multiple query.&#10; *&#10; * O(qlogn) where q = query.length, n = a.length.&#10; *&#10; * @param a array&#10; * @param query queries([l, r))&#10; * @return answers to the queries&#10; */&#10;public static int[] answerDistinctQuery(int[] a, int[][] query) {&#10;    int n = a.length;&#10;    int q = query.length;&#10;&#10;    int[][] qinfo = new int[q][3];&#10;    for (int i = 0; i &lt; q ; i++) {&#10;        qinfo[i] = new int[]{query[i][0], query[i][1], i};&#10;    }&#10;    Arrays.sort(qinfo, (o1, o2) -&gt; o1[1] - o2[1]);&#10;&#10;    // last index that number i appeared.&#10;    // it may need value compression.&#10;    int[] lastAppeared = new int[1000000];&#10;    Arrays.fill(lastAppeared, -1);&#10;    FenwickTree bit = new FenwickTree(n+1);&#10;&#10;    int head = 0;&#10;    int[] ret = new int[q];&#10;    for (int i = 0; i &lt; q ; i++) {&#10;        while (head &lt; qinfo[i][1]) {&#10;            int num = a[head];&#10;            if (lastAppeared[num] != -1) {&#10;                bit.set(lastAppeared[num]+1, 0);&#10;            }&#10;            lastAppeared[num] = head;&#10;            bit.set(lastAppeared[num]+1, 1);&#10;            head++;&#10;        }&#10;        ret[qinfo[i][2]] = (int)bit.range(qinfo[i][0]+1, qinfo[i][1]);&#10;    }&#10;    return ret;&#10;}&#10;" description="区間中のuniqueな数値を計上する" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="utils.distinctnumberrange2" value="/**&#10; * Computes distinct numbers of give array.&#10; * Answers multiple query.&#10; *&#10; * O((n+q)(logn+logq)) where q = query.length, n = a.length.&#10; *&#10; * @refs https://twitter.com/uwitenpen/status/761777092069462016&#10; * @param a array&#10; * @param query queries([l, r))&#10; * @return answers to the queries&#10; */&#10;public static int[] answerDistinctQuery(int[] a, int[][] query) {&#10;    int n = a.length;&#10;&#10;    // last index that number i appeared.&#10;    // it may need value compression.&#10;    int[] lastAppeared = new int[1000000];&#10;    Arrays.fill(lastAppeared, -1);&#10;&#10;    // same number ranges.&#10;    List&lt;int[]&gt; ranges = new ArrayList&lt;&gt;();&#10;    int[] ct = new int[1000000];&#10;    for (int i = 0; i &lt; n ; i++) {&#10;        ct[a[i]]++;&#10;        if (lastAppeared[a[i]] == -1) {&#10;            lastAppeared[a[i]] = i;&#10;            continue;&#10;        }&#10;        ranges.add(new int[]{lastAppeared[a[i]], i+1});&#10;        lastAppeared[a[i]] = i;&#10;    }&#10;&#10;    int[][] ranges0 = new int[ranges.size()][];&#10;    for (int i = 0; i &lt; ranges.size() ; i++) {&#10;        ranges0[i] = ranges.get(i);&#10;    }&#10;    int[] coveringRanges = CountRangeCoveringRange.answerCountQuery(ranges0, query);&#10;    int q = query.length;&#10;    int[] ret = new int[q];&#10;    for (int i = 0; i &lt; q ; i++) {&#10;        ret[i] = (query[i][1] - query[i][0]) - coveringRanges[i];&#10;    }&#10;    return ret;&#10;}&#10;" description="区間中のuniqueな数値を計上する(オンラインクエリ版)" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="utils.io.buildgraph_edges_array" value="static int[][] buildGraph(int n, int[][] edges) {&#10;    int m = edges.length;&#10;    int[][] graph = new int[n][];&#10;    int[] deg = new int[n];&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = edges[i][0];&#10;        int b = edges[i][1];&#10;        deg[a]++;&#10;        deg[b]++;&#10;    }&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        graph[i] = new int[deg[i]];&#10;    }&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = edges[i][0];&#10;        int b = edges[i][1];&#10;        graph[a][--deg[a]] = b;&#10;        graph[b][--deg[b]] = a;&#10;    }&#10;    return graph;&#10;}&#10;" description="int[][] style" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="utils.io.buildgraph_edges_list" value="static int[][] buildGraph(int n, List&lt;int[]&gt; edges) {&#10;    int m = edges.size();&#10;    int[][] graph = new int[n][];&#10;    int[] deg = new int[n];&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = edges.get(i)[0];&#10;        int b = edges.get(i)[1];&#10;        deg[a]++;&#10;        deg[b]++;&#10;    }&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        graph[i] = new int[deg[i]];&#10;    }&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = edges.get(i)[0];&#10;        int b = edges.get(i)[1];&#10;        graph[a][--deg[a]] = b;&#10;        graph[b][--deg[b]] = a;&#10;    }&#10;    return graph;&#10;}" description="List&lt;int[]&gt; style" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="utils.io.buildgraph_pair" value="static int[][] buildGraph(int[] l, int[] r) {&#10;    int n = 0;&#10;    for (int i = 0 ; i &lt; l.length ; i++) {&#10;        n = Math.max(n, l[i]);&#10;        n = Math.max(n, r[i]);&#10;    }&#10;    int m = l.length;&#10;    int[][] edges = new int[m][];&#10;    int[][] graph = new int[n][];&#10;    int[] deg = new int[n];&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        deg[l[i]]++;&#10;        deg[r[i]]++;&#10;        edges[i] = new int[]{l[i], r[i]};&#10;    }&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        graph[i] = new int[deg[i]];&#10;    }&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = edges[i][0];&#10;        int b = edges[i][1];&#10;        graph[a][--deg[a]] = b;&#10;        graph[b][--deg[b]] = a;&#10;    }&#10;    return graph;&#10;}" description="int[] a, int[] b style" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="utils.io.buildgraph_stdin" value="static int[][] buildGraph(InputReader in, int n, int m) {&#10;    int[][] edges = new int[m][];&#10;    int[][] graph = new int[n][];&#10;    int[] deg = new int[n];&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = in.nextInt()-1;&#10;        int b = in.nextInt()-1;&#10;        deg[a]++;&#10;        deg[b]++;&#10;        edges[i] = new int[]{a, b};&#10;    }&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        graph[i] = new int[deg[i]];&#10;    }&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = edges[i][0];&#10;        int b = edges[i][1];&#10;        graph[a][--deg[a]] = b;&#10;        graph[b][--deg[b]] = a;&#10;    }&#10;    return graph;&#10;}" description="stdin style" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="utils.io.buildweightedgraph_stdin" value="static int[][][] buildWeightedGraph(InputReader in, int n, int m) {&#10;    int[][] edges = new int[m][];&#10;    int[][][] graph = new int[n][][];&#10;    int[] deg = new int[n];&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = in.nextInt()-1;&#10;        int b = in.nextInt()-1;&#10;        int w = in.nextInt();&#10;        deg[a]++;&#10;        deg[b]++;&#10;        edges[i] = new int[]{a, b, w};&#10;    }&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        graph[i] = new int[deg[i]][2];&#10;    }&#10;    for (int i = 0 ; i &lt; m ; i++) {&#10;        int a = edges[i][0];&#10;        int b = edges[i][1];&#10;        int w = edges[i][2];&#10;        graph[a][--deg[a]][0] = b;&#10;        graph[b][--deg[b]][0] = a;&#10;        graph[a][deg[a]][1] = w;&#10;        graph[b][deg[b]][1] = w;&#10;    }&#10;    return graph;&#10;}" description="stdin style" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="utils.io.ir" value="public class InputReader {&#10;    private static final int BUFFER_LENGTH = 1&lt;&lt;10;&#10;&#10;    private InputStream stream;&#10;    private byte[] buf = new byte[BUFFER_LENGTH];&#10;    private int curChar;&#10;    private int numChars;&#10;&#10;    public InputReader(InputStream stream) {&#10;        this.stream = stream;&#10;    }&#10;&#10;    private int[] nextInts(int n) {&#10;        int[] ret = new int[n];&#10;        for (int i = 0; i &lt; n; i++) {&#10;            ret[i] = nextInt();&#10;        }&#10;        return ret;&#10;    }&#10;&#10;    private int[][] nextIntTable(int n, int m) {&#10;        int[][] ret = new int[n][m];&#10;        for (int i = 0; i &lt; n; i++) {&#10;            for (int j = 0; j &lt; m; j++) {&#10;                ret[i][j] = nextInt();&#10;            }&#10;        }&#10;        return ret;&#10;    }&#10;&#10;    private long[] nextLongs(int n) {&#10;        long[] ret = new long[n];&#10;        for (int i = 0; i &lt; n; i++) {&#10;            ret[i] = nextLong();&#10;        }&#10;        return ret;&#10;    }&#10;&#10;    private long[][] nextLongTable(int n, int m) {&#10;        long[][] ret = new long[n][m];&#10;        for (int i = 0; i &lt; n; i++) {&#10;            for (int j = 0; j &lt; m; j++) {&#10;                ret[i][j] = nextLong();&#10;            }&#10;        }&#10;        return ret;&#10;    }&#10;&#10;    private double[] nextDoubles(int n) {&#10;        double[] ret = new double[n];&#10;        for (int i = 0; i &lt; n; i++) {&#10;            ret[i] = nextDouble();&#10;        }&#10;        return ret;&#10;    }&#10;&#10;    private double[][] nextDoubleTable(int n, int m) {&#10;        double[][] ret = new double[n][m];&#10;        for (int i = 0; i &lt; n; i++) {&#10;            for (int j = 0; j &lt; m; j++) {&#10;                ret[i][j] = nextLong();&#10;            }&#10;        }&#10;        return ret;&#10;    }&#10;&#10;    private int next() {&#10;        if (numChars == -1) {&#10;            throw new InputMismatchException();&#10;        }&#10;        if (curChar &gt;= numChars) {&#10;            curChar = 0;&#10;            try {&#10;                numChars = stream.read(buf);&#10;            } catch (IOException e) {&#10;                throw new InputMismatchException();&#10;            }&#10;            if (numChars &lt;= 0)&#10;                return -1;&#10;        }&#10;        return buf[curChar++];&#10;    }&#10;&#10;    public char nextChar() {&#10;        int c = next();&#10;        while (isSpaceChar(c)) {&#10;            c = next();&#10;        }&#10;        if ('a' &lt;= c &amp;&amp; c &lt;= 'z') {&#10;            return (char) c;&#10;        }&#10;        if ('A' &lt;= c &amp;&amp; c &lt;= 'Z') {&#10;            return (char) c;&#10;        }&#10;        throw new InputMismatchException();&#10;    }&#10;&#10;    public String nextToken() {&#10;        int c = next();&#10;        while (isSpaceChar(c)) {&#10;            c = next();&#10;        }&#10;        StringBuilder res = new StringBuilder();&#10;        do {&#10;            res.append((char) c);&#10;            c = next();&#10;        } while (!isSpaceChar(c));&#10;        return res.toString();&#10;    }&#10;&#10;    public int nextInt() {&#10;        int c = skipWhileSpace();&#10;        int sgn = 1;&#10;        if (c == '-') {&#10;            sgn = -1;&#10;            c = next();&#10;        }&#10;        int res = 0;&#10;        do {&#10;            if (c &lt; '0' || c &gt; '9') {&#10;                throw new InputMismatchException();&#10;            }&#10;            res *= 10;&#10;            res += c-'0';&#10;            c = next();&#10;        } while (!isSpaceChar(c));&#10;        return res*sgn;&#10;    }&#10;&#10;    public long nextLong() {&#10;        int c = skipWhileSpace();&#10;        long sgn = 1;&#10;        if (c == '-') {&#10;            sgn = -1;&#10;            c = next();&#10;        }&#10;        long res = 0;&#10;        do {&#10;            if (c &lt; '0' || c &gt; '9') {&#10;                throw new InputMismatchException();&#10;            }&#10;            res *= 10;&#10;            res += c-'0';&#10;            c = next();&#10;        } while (!isSpaceChar(c));&#10;        return res*sgn;&#10;    }&#10;&#10;&#10;    public double nextDouble() {&#10;        // TODO: we should make some effort to handle this...&#10;        return Double.valueOf(nextToken());&#10;    }&#10;&#10;    public int skipWhileSpace() {&#10;        int c = next();&#10;        while (isSpaceChar(c)) {&#10;            c = next();&#10;        }&#10;        return c;&#10;    }&#10;&#10;    public boolean isSpaceChar(int c) {&#10;        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;&#10;    }&#10;}&#10;" description="input reader" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="utils.rand.xorshift" value="public class XorShift {&#10;    private int x = 123456789;&#10;    private int y = 362436069;&#10;    private int z = 521288629;&#10;    private int w = 88675123;&#10;&#10;    public int nextInt(final int n) {&#10;        final int t = x^(x&lt;&lt;11);&#10;        x = y;&#10;        y = z;&#10;        z = w;&#10;        w = (w^(w&gt;&gt;&gt;19))^(t^(t&gt;&gt;&gt;8));&#10;        final int r = w%n;&#10;        return r &lt; 0 ? r+n : r;&#10;    }&#10;&#10;    public int next() {&#10;        final int t = x^(x&lt;&lt;11);&#10;        x = y;&#10;        y = z;&#10;        z = w;&#10;        w = w^(w&gt;&gt;&gt;19)^(t^(t&gt;&gt;&gt;8));&#10;        return w;&#10;    }&#10;&#10;    public double nextDouble() {&#10;        return (double) (next()+(1L&lt;&lt;31))/(1L&lt;&lt;32);&#10;    }&#10;&#10;    public long nextLong() {&#10;        return ((long) next()&lt;&lt;32)^(((long) next()&lt;&lt;32)&gt;&gt;&gt;32);&#10;    }&#10;}&#10;" description="XorShift" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="utils.slideminvalue" value="/**&#10; * Computes slide-window min value.&#10; * Returns array of length (|a|-k+1), i-th element means min(a[i],a[i+1],...,a[i+k-1]).&#10; *&#10; * @param a original array&#10; * @param k window size&#10; * @return min values&#10; */&#10;public static int[] slideMin(int[] a, int k) {&#10;    int n = a.length;&#10;&#10;    Deque&lt;Integer&gt; deq = new ArrayDeque&lt;&gt;();&#10;    int[] slideMin = new int[n-k+1];&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        while (deq.size() &gt;= 1 &amp;&amp; a[deq.peekLast()] &gt;= a[i]) {&#10;            deq.pollLast();&#10;        }&#10;        deq.add(i);&#10;&#10;        if (i - k + 1 &gt;= 0) {&#10;            int top = deq.peekFirst();&#10;            slideMin[i-k+1] = a[top];&#10;            if (top == i - k + 1) {&#10;                deq.pollFirst();&#10;            }&#10;        }&#10;    }&#10;    return slideMin;&#10;}" description="スライド最小値" toReformat="true" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>
<template name="utils.stockspan" value="/**&#10; * For each i, computes the maximum position x s.t. a[x] &gt;= a[i] and x &lt; i.&#10; * If there is no such position, x will be -1.&#10; *&#10; * O(n)&#10; *&#10; * @param a&#10; * @return maximum position x for each i&#10; */&#10;static int[] stockSpanLeft(int[] a) {&#10;    int n = a.length;&#10;    int head = 0;&#10;    int[] stk = new int[n+1];&#10;    int[] L = new int[n];&#10;    for (int i = 0 ; i &lt; n ; i++) {&#10;        while (head &gt;= 1 &amp;&amp; a[i] &gt; a[stk[head-1]]) {&#10;            head--;&#10;        }&#10;        L[i] = (head &gt;= 1) ? stk[head-1] : -1;&#10;        stk[head++] = i;&#10;    }&#10;    return L;&#10;}&#10;&#10;/**&#10; * For each i, computes the minimum position x s.t. a[i] &lt;= a[x] and i &lt; x.&#10; * If there is no such position, x will be n. (n = a.length)&#10; *&#10; * O(n)&#10; *&#10; * @param a&#10; * @return minimum position x for each i&#10; */&#10;static int[] stockSpanRight(int[] a) {&#10;    int n = a.length;&#10;    int head = 0;&#10;    int[] stk = new int[n+1];&#10;    int[] R = new int[n];&#10;    for (int i = n-1 ; i &gt;= 0 ; i--) {&#10;        while (head &gt;= 1 &amp;&amp; a[i] &gt; a[stk[head-1]]) {&#10;            head--;&#10;        }&#10;        R[i] = (head &gt;= 1) ? stk[head-1] : n;&#10;        stk[head++] = i;&#10;    }&#10;    return R;&#10;}" description="Stock Span Problem" toReformat="false" toShortenFQNames="true">
<context>
  <option name="JAVA_DECLARATION" value="true" />
</context>
</template>